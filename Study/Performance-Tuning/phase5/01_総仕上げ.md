# Phase 5-1: 総仕上げ ～ パフォーマンス改善プロジェクト ～

## 学習目標

この単元を終えると、以下ができるようになります：

- パフォーマンス問題を体系的に解決できる
- 改善効果を定量的に示せる
- パフォーマンスレビューができる

## 総合演習: API パフォーマンス改善

### シナリオ

```
E コマース API のレスポンスが遅い。
目標: P95 を 500ms 以下に改善
```

### 改善前のコード

```python
# before.py
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session
import time

app = FastAPI()

@app.get('/products')
def get_products(db: Session = Depends(get_db)):
    # 問題1: N+1 問題
    products = db.query(Product).all()
    
    result = []
    for product in products:
        # 問題2: 各商品でループ内クエリ
        category = db.query(Category).get(product.category_id)
        reviews = db.query(Review).filter_by(product_id=product.id).all()
        
        # 問題3: 同期的な外部 API 呼び出し
        stock = requests.get(f'http://inventory/stock/{product.id}').json()
        
        result.append({
            'id': product.id,
            'name': product.name,
            'category': category.name,
            'review_count': len(reviews),
            'stock': stock['quantity']
        })
    
    return result
```

### 改善後のコード

```python
# after.py
from fastapi import FastAPI, Depends
from sqlalchemy.orm import Session, selectinload, joinedload
import httpx
import asyncio
import redis
import json

app = FastAPI()
cache = redis.from_url('redis://localhost:6379', decode_responses=True)

@app.get('/products')
async def get_products(db: Session = Depends(get_db)):
    # 改善1: キャッシュ確認
    cached = cache.get('products:list')
    if cached:
        return json.loads(cached)
    
    # 改善2: Eager Loading で N+1 解決
    products = db.query(Product).options(
        joinedload(Product.category),
        selectinload(Product.reviews)
    ).all()
    
    # 改善3: 非同期で在庫 API を並行呼び出し
    async with httpx.AsyncClient() as client:
        stock_tasks = [
            client.get(f'http://inventory/stock/{p.id}')
            for p in products
        ]
        stock_responses = await asyncio.gather(*stock_tasks)
    
    stocks = {
        products[i].id: resp.json()['quantity']
        for i, resp in enumerate(stock_responses)
    }
    
    result = [
        {
            'id': p.id,
            'name': p.name,
            'category': p.category.name,
            'review_count': len(p.reviews),
            'stock': stocks[p.id]
        }
        for p in products
    ]
    
    # 改善4: 結果をキャッシュ
    cache.setex('products:list', 300, json.dumps(result))
    
    return result
```

## パフォーマンス改善チェックリスト

```markdown
## データベース
- [ ] EXPLAIN でクエリプランを確認
- [ ] N+1 問題をチェック
- [ ] 適切なインデックスを追加
- [ ] 必要なカラムのみ SELECT

## キャッシュ
- [ ] 頻繁にアクセスするデータをキャッシュ
- [ ] 適切な TTL を設定
- [ ] キャッシュ無効化戦略を実装

## 非同期/並列
- [ ] I/O バウンドな処理を非同期化
- [ ] CPU バウンドな処理を並列化
- [ ] 外部 API 呼び出しを並行実行

## 計測
- [ ] レスポンスタイムを計測
- [ ] パーセンタイル（P50, P95, P99）を確認
- [ ] ボトルネックを特定
```

## 改善効果の測定

```python
# benchmark.py
import httpx
import asyncio
import statistics
import time

async def benchmark(url: str, num_requests: int = 100):
    times = []
    
    async with httpx.AsyncClient() as client:
        for _ in range(num_requests):
            start = time.perf_counter()
            await client.get(url)
            times.append((time.perf_counter() - start) * 1000)
    
    sorted_times = sorted(times)
    n = len(sorted_times)
    
    return {
        'mean': statistics.mean(times),
        'p50': sorted_times[int(n * 0.5)],
        'p95': sorted_times[int(n * 0.95)],
        'p99': sorted_times[int(n * 0.99)],
    }

async def compare():
    print('=== Before ===')
    before = await benchmark('http://localhost:8000/products/before')
    print(f'P50: {before["p50"]:.0f}ms, P95: {before["p95"]:.0f}ms')
    
    print('\n=== After ===')
    after = await benchmark('http://localhost:8000/products/after')
    print(f'P50: {after["p50"]:.0f}ms, P95: {after["p95"]:.0f}ms')
    
    print(f'\n改善率: {(1 - after["p95"]/before["p95"]) * 100:.0f}%')

asyncio.run(compare())
```

## カリキュラム完了！

おめでとうございます！パフォーマンスチューニングのカリキュラムを完了しました。

### 学んだこと

1. **パフォーマンス基礎** - 指標、計測
2. **プロファイリング** - ボトルネック特定
3. **データベース最適化** - EXPLAIN、クエリ改善
4. **インデックス設計** - 複合インデックス、カバリング
5. **キャッシュ戦略** - 多層キャッシュ
6. **N+1 問題** - 検出と解決
7. **非同期処理** - async/await
8. **並列処理** - multiprocessing

### 次のステップ

- **負荷テスト** - Locust、k6
- **APM** - New Relic、Datadog
- **CDN** - CloudFront、Cloudflare
