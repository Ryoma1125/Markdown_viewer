# Phase 2-2: インデックス設計

## 学習目標

この単元を終えると、以下ができるようになります：

- 適切なインデックスを設計できる
- 複合インデックスを理解できる
- インデックスの落とし穴を知る

## インデックスの基本

```mermaid
graph LR
    A[インデックスなし] --> B[全件スキャン<br/>O(n)]
    C[インデックスあり] --> D[B-Tree検索<br/>O(log n)]
```

## インデックスの種類

| 種類 | 用途 | 例 |
|------|------|-----|
| B-Tree | 一般的な検索、範囲 | =, <, >, BETWEEN |
| Hash | 完全一致のみ | = |
| GIN | 配列、全文検索 | @>, LIKE |
| GiST | 地理情報 | 位置検索 |

## ハンズオン

### 準備

```sql
-- テストテーブル
CREATE TABLE orders (
    id SERIAL PRIMARY KEY,
    user_id INTEGER,
    product_id INTEGER,
    status VARCHAR(20),
    amount DECIMAL(10, 2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 100万件のデータ
INSERT INTO orders (user_id, product_id, status, amount, created_at)
SELECT 
    (random() * 10000)::int,
    (random() * 1000)::int,
    CASE (random() * 3)::int 
        WHEN 0 THEN 'pending'
        WHEN 1 THEN 'completed'
        ELSE 'cancelled'
    END,
    (random() * 10000)::decimal(10, 2),
    NOW() - (random() * 365 || ' days')::interval
FROM generate_series(1, 1000000);
```

### 演習1: 単一カラムインデックス

```sql
-- インデックスなし
EXPLAIN ANALYZE SELECT * FROM orders WHERE user_id = 5000;
-- Seq Scan: ~200ms

-- インデックス作成
CREATE INDEX idx_orders_user_id ON orders(user_id);

-- インデックスあり
EXPLAIN ANALYZE SELECT * FROM orders WHERE user_id = 5000;
-- Index Scan: ~1ms
```

### 演習2: 複合インデックス

```sql
-- ユーザーと日付で検索
EXPLAIN ANALYZE 
SELECT * FROM orders 
WHERE user_id = 5000 AND created_at > '2024-01-01';

-- 複合インデックス
CREATE INDEX idx_orders_user_date ON orders(user_id, created_at);

-- 検索順序が重要！
-- ✅ user_id = 5000 AND created_at > '2024-01-01'
-- ✅ user_id = 5000
-- ❌ created_at > '2024-01-01'（最初のカラムがない）
```

### 演習3: カバリングインデックス

```sql
-- 通常のクエリ
EXPLAIN ANALYZE SELECT user_id, amount FROM orders WHERE user_id = 5000;
-- Index Scan + テーブル読み取り

-- カバリングインデックス（必要なカラムを含む）
CREATE INDEX idx_orders_user_amount ON orders(user_id) INCLUDE (amount);

-- Index Only Scan（テーブル読み取り不要）
EXPLAIN ANALYZE SELECT user_id, amount FROM orders WHERE user_id = 5000;
```

### 演習4: 部分インデックス

```sql
-- status = 'pending' の注文だけよく検索する
CREATE INDEX idx_orders_pending ON orders(user_id, created_at) 
WHERE status = 'pending';

-- このクエリで使われる
EXPLAIN ANALYZE 
SELECT * FROM orders 
WHERE user_id = 5000 AND status = 'pending';
```

## インデックスの落とし穴

### 1. インデックスが使われないケース

```sql
-- ❌ 関数でカラムを包む
SELECT * FROM orders WHERE LOWER(status) = 'pending';

-- ✅ 関数インデックスを使う
CREATE INDEX idx_orders_status_lower ON orders(LOWER(status));

-- ❌ 型が一致しない
SELECT * FROM orders WHERE user_id = '5000';  -- 文字列

-- ✅ 正しい型
SELECT * FROM orders WHERE user_id = 5000;  -- 整数
```

### 2. カーディナリティ

```sql
-- 高カーディナリティ（値が多様）→ インデックス効果大
-- email, user_id 等

-- 低カーディナリティ（値が少ない）→ 効果小
-- status, is_active 等
```

### 3. インデックスの維持コスト

```python
# index_analysis.py
"""
インデックスは：
- SELECT を高速化
- INSERT/UPDATE/DELETE を遅くする
- ストレージを消費

バランスが重要！
"""

def should_create_index(
    read_ratio: float,    # 読み取り割合
    table_size: int,      # 行数
    cardinality: float    # カーディナリティ
) -> bool:
    """インデックスを作成すべきか判定"""
    
    # 読み取りが少ない → 不要
    if read_ratio < 0.7:
        return False
    
    # テーブルが小さい → 不要
    if table_size < 1000:
        return False
    
    # カーディナリティが低い → 効果薄
    if cardinality < 0.1:
        return False
    
    return True
```

## インデックス管理

```sql
-- 未使用インデックスの確認
SELECT 
    schemaname,
    tablename,
    indexname,
    idx_scan,
    idx_tup_read,
    idx_tup_fetch
FROM pg_stat_user_indexes
WHERE idx_scan = 0
ORDER BY pg_relation_size(indexrelid) DESC;

-- インデックスサイズ
SELECT 
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) as size
FROM pg_stat_user_indexes
WHERE schemaname = 'public'
ORDER BY pg_relation_size(indexrelid) DESC;
```

## 理解度確認

### 問題

複合インデックス `(user_id, created_at)` が使われるクエリはどれか。

**A.** `WHERE created_at > '2024-01-01'`

**B.** `WHERE user_id = 1 AND created_at > '2024-01-01'`

**C.** `WHERE created_at > '2024-01-01' AND user_id = 1`

**D.** B と C の両方

---

### 解答・解説

**正解: D**

複合インデックスは最左のカラムから使われます。B と C はどちらも user_id を含むので使われます（オプティマイザが順序を調整）。A は user_id がないので使われません。

---

## 次のステップ

インデックス設計を学びました。次はキャッシュ戦略を学びましょう。

**次の単元**: [Phase 3-1: キャッシュ戦略](../phase3/01_キャッシュ戦略.md)
