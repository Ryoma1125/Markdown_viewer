# Phase 2-1: データベース最適化

## 学習目標

この単元を終えると、以下ができるようになります：

- EXPLAIN を読める
- クエリを最適化できる
- スロークエリを特定できる

## EXPLAIN の読み方

### 基本構文

```sql
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'alice@example.com';
```

### 出力の見方

```
Seq Scan on users  (cost=0.00..35.50 rows=1 width=100) (actual time=0.015..0.250 rows=1 loops=1)
  Filter: (email = 'alice@example.com'::text)
  Rows Removed by Filter: 999
Planning Time: 0.100 ms
Execution Time: 0.270 ms
```

| 項目 | 説明 |
|------|------|
| Seq Scan | 全件スキャン（遅い） |
| Index Scan | インデックス使用（速い） |
| cost | 推定コスト |
| actual time | 実際の時間 |
| rows | 行数 |

## ハンズオン

### 環境準備

```yaml
# docker-compose.yml
services:
  postgres:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
```

```sql
-- テストデータ作成
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    email VARCHAR(255),
    name VARCHAR(100),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- 10万件のダミーデータ
INSERT INTO users (email, name)
SELECT 
    'user' || i || '@example.com',
    'User ' || i
FROM generate_series(1, 100000) AS i;
```

### 演習1: 全件スキャン vs インデックス

```sql
-- インデックスなし（遅い）
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'user50000@example.com';

-- 結果: Seq Scan（全件スキャン）
```

```sql
-- インデックス作成
CREATE INDEX idx_users_email ON users(email);

-- インデックスあり（速い）
EXPLAIN ANALYZE SELECT * FROM users WHERE email = 'user50000@example.com';

-- 結果: Index Scan（インデックス使用）
```

### 演習2: クエリの改善

```sql
-- 悪い例: LIKE '%...%'
EXPLAIN ANALYZE SELECT * FROM users WHERE email LIKE '%50000%';
-- Seq Scan（インデックス使えない）

-- 良い例: 前方一致
EXPLAIN ANALYZE SELECT * FROM users WHERE email LIKE 'user50000%';
-- Index Scan（インデックス使える）
```

### 演習3: SELECT * を避ける

```sql
-- 悪い例
SELECT * FROM users WHERE id < 100;

-- 良い例（必要なカラムのみ）
SELECT id, email FROM users WHERE id < 100;
```

### 演習4: Python からクエリ分析

```python
# query_analyzer.py
import psycopg2
import json

def analyze_query(conn, query: str) -> dict:
    """クエリを分析"""
    with conn.cursor() as cur:
        cur.execute(f'EXPLAIN (ANALYZE, FORMAT JSON) {query}')
        result = cur.fetchone()[0]
        return result[0]

def format_plan(plan: dict, indent: int = 0) -> str:
    """実行プランを整形"""
    node = plan.get('Plan', plan)
    prefix = '  ' * indent
    
    output = f'{prefix}{node["Node Type"]}'
    if 'Relation Name' in node:
        output += f' on {node["Relation Name"]}'
    
    output += f' (cost={node["Total Cost"]:.2f}'
    if 'Actual Total Time' in node:
        output += f', time={node["Actual Total Time"]:.2f}ms'
    output += ')\n'
    
    for child in node.get('Plans', []):
        output += format_plan(child, indent + 1)
    
    return output

# 使用例
conn = psycopg2.connect('postgresql://postgres:password@localhost/postgres')
plan = analyze_query(conn, "SELECT * FROM users WHERE email = 'user50000@example.com'")
print(format_plan(plan))
```

## スロークエリログ

### PostgreSQL 設定

```sql
-- スロークエリログを有効化
ALTER SYSTEM SET log_min_duration_statement = 100;  -- 100ms 以上
SELECT pg_reload_conf();
```

### Python でスロークエリ検出

```python
# slow_query_detector.py
import time
import functools
import logging

logging.basicConfig(level=logging.WARNING)
logger = logging.getLogger(__name__)

def log_slow_query(threshold_ms: float = 100):
    def decorator(func):
        @functools.wraps(func)
        def wrapper(*args, **kwargs):
            start = time.perf_counter()
            result = func(*args, **kwargs)
            elapsed = (time.perf_counter() - start) * 1000
            
            if elapsed > threshold_ms:
                logger.warning(
                    f'Slow query detected: {func.__name__} took {elapsed:.2f}ms'
                )
            
            return result
        return wrapper
    return decorator

# 使用例
@log_slow_query(threshold_ms=50)
def get_user_by_email(conn, email: str):
    with conn.cursor() as cur:
        cur.execute('SELECT * FROM users WHERE email = %s', (email,))
        return cur.fetchone()
```

## クエリ最適化のコツ

| やること | やらないこと |
|---------|-------------|
| 必要なカラムのみ SELECT | SELECT * |
| インデックスを使う | 関数でカラムを包む |
| LIMIT を使う | 全件取得 |
| JOIN の順序を意識 | 無駄な JOIN |

## 理解度確認

### 問題

EXPLAIN の結果で「Seq Scan」と表示された場合、何を意味するか。

**A.** インデックスを使用している

**B.** 全件スキャンしている

**C.** 並列処理している

**D.** キャッシュを使用している

---

### 解答・解説

**正解: B**

Seq Scan（Sequential Scan）は全件スキャンを意味し、大きなテーブルでは非常に遅くなります。インデックスを作成することで Index Scan に改善できる可能性があります。

---

## 次のステップ

データベース最適化を学びました。次はインデックス設計を学びましょう。

**次の単元**: [Phase 2-2: インデックス設計](./02_インデックス設計.md)
