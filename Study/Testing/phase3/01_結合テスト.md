# Phase 3-1: 結合テスト

## 学習目標

この単元を終えると、以下ができるようになります：

- 結合テストの目的を説明できる
- FastAPI のテストを書ける
- データベースを使ったテストができる

## 概念解説

### 結合テストとは

```mermaid
graph LR
    A[API] --> B[Service]
    B --> C[Repository]
    C --> D[Database]
    
    style A fill:#90EE90
    style B fill:#90EE90
    style C fill:#90EE90
    style D fill:#FFE4B5
```

**結合テスト** = 複数のコンポーネントを組み合わせてテスト

### 単体テスト vs 結合テスト

| 観点 | 単体テスト | 結合テスト |
|------|----------|----------|
| 対象 | 関数/クラス | コンポーネント間 |
| 速度 | 非常に速い | 遅い |
| 依存 | モック化 | 実際に接続 |
| 目的 | ロジック検証 | 連携検証 |

## ハンズオン

### 演習1: FastAPI のテスト

```python
# main.py
from fastapi import FastAPI, HTTPException
from pydantic import BaseModel
from typing import List, Optional

app = FastAPI()

class User(BaseModel):
    id: int
    name: str
    email: str

users_db: dict[int, User] = {}
user_id_counter = 0

@app.post("/users", response_model=User, status_code=201)
def create_user(name: str, email: str):
    global user_id_counter
    user_id_counter += 1
    user = User(id=user_id_counter, name=name, email=email)
    users_db[user.id] = user
    return user

@app.get("/users/{user_id}", response_model=User)
def get_user(user_id: int):
    if user_id not in users_db:
        raise HTTPException(status_code=404, detail="User not found")
    return users_db[user_id]

@app.get("/users", response_model=List[User])
def list_users():
    return list(users_db.values())
```

```python
# test_main.py
import pytest
from fastapi.testclient import TestClient
from main import app, users_db

@pytest.fixture
def client():
    users_db.clear()
    return TestClient(app)

class TestUserAPI:
    
    def test_create_user(self, client):
        response = client.post(
            "/users",
            params={"name": "John", "email": "john@example.com"}
        )
        
        assert response.status_code == 201
        data = response.json()
        assert data["name"] == "John"
        assert data["email"] == "john@example.com"
        assert "id" in data
    
    def test_get_user(self, client):
        # まず作成
        create_response = client.post(
            "/users",
            params={"name": "Jane", "email": "jane@example.com"}
        )
        user_id = create_response.json()["id"]
        
        # 取得
        response = client.get(f"/users/{user_id}")
        
        assert response.status_code == 200
        assert response.json()["name"] == "Jane"
    
    def test_get_user_not_found(self, client):
        response = client.get("/users/999")
        
        assert response.status_code == 404
        assert response.json()["detail"] == "User not found"
    
    def test_list_users(self, client):
        # 2人作成
        client.post("/users", params={"name": "User1", "email": "u1@example.com"})
        client.post("/users", params={"name": "User2", "email": "u2@example.com"})
        
        response = client.get("/users")
        
        assert response.status_code == 200
        assert len(response.json()) == 2
```

### 演習2: 非同期 API のテスト

```python
# async_main.py
from fastapi import FastAPI
import httpx

app = FastAPI()

@app.get("/external-data")
async def get_external_data():
    async with httpx.AsyncClient() as client:
        response = await client.get("https://api.example.com/data")
        return response.json()
```

```python
# test_async_main.py
import pytest
from httpx import AsyncClient, ASGITransport
from async_main import app

@pytest.fixture
async def async_client():
    transport = ASGITransport(app=app)
    async with AsyncClient(transport=transport, base_url="http://test") as client:
        yield client

@pytest.mark.asyncio
async def test_async_endpoint(async_client):
    response = await async_client.get("/")
    assert response.status_code == 200
```

### 演習3: データベース結合テスト

```python
# models.py
from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker

Base = declarative_base()

class User(Base):
    __tablename__ = "users"
    
    id = Column(Integer, primary_key=True, index=True)
    name = Column(String, nullable=False)
    email = Column(String, unique=True, nullable=False)
```

```python
# database.py
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

DATABASE_URL = "postgresql://user:pass@localhost/db"

engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()
```

```python
# test_database.py
import pytest
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from models import Base, User

# テスト用SQLite
TEST_DATABASE_URL = "sqlite:///./test.db"

@pytest.fixture(scope="function")
def db_session():
    # テスト用エンジン作成
    engine = create_engine(
        TEST_DATABASE_URL,
        connect_args={"check_same_thread": False}
    )
    
    # テーブル作成
    Base.metadata.create_all(bind=engine)
    
    # セッション作成
    TestSession = sessionmaker(bind=engine)
    session = TestSession()
    
    yield session
    
    # クリーンアップ
    session.close()
    Base.metadata.drop_all(bind=engine)

class TestUserRepository:
    
    def test_create_user(self, db_session):
        user = User(name="John", email="john@example.com")
        db_session.add(user)
        db_session.commit()
        
        assert user.id is not None
    
    def test_get_user(self, db_session):
        # 作成
        user = User(name="Jane", email="jane@example.com")
        db_session.add(user)
        db_session.commit()
        
        # 取得
        found = db_session.query(User).filter(User.id == user.id).first()
        
        assert found is not None
        assert found.name == "Jane"
    
    def test_unique_email(self, db_session):
        from sqlalchemy.exc import IntegrityError
        
        user1 = User(name="User1", email="same@example.com")
        db_session.add(user1)
        db_session.commit()
        
        user2 = User(name="User2", email="same@example.com")
        db_session.add(user2)
        
        with pytest.raises(IntegrityError):
            db_session.commit()
```

### 演習4: Docker を使った結合テスト

```python
# conftest.py
import pytest
import docker
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
import time

@pytest.fixture(scope="session")
def postgres_container():
    client = docker.from_env()
    
    # PostgreSQLコンテナ起動
    container = client.containers.run(
        "postgres:15",
        environment={
            "POSTGRES_USER": "test",
            "POSTGRES_PASSWORD": "test",
            "POSTGRES_DB": "testdb"
        },
        ports={"5432/tcp": 5433},
        detach=True,
    )
    
    # 起動待ち
    time.sleep(3)
    
    yield container
    
    # クリーンアップ
    container.stop()
    container.remove()

@pytest.fixture(scope="function")
def db_session(postgres_container):
    engine = create_engine(
        "postgresql://test:test@localhost:5433/testdb"
    )
    Base.metadata.create_all(bind=engine)
    
    Session = sessionmaker(bind=engine)
    session = Session()
    
    yield session
    
    session.close()
    Base.metadata.drop_all(bind=engine)
```

### 演習5: testcontainers を使う

```python
# pip install testcontainers
from testcontainers.postgres import PostgresContainer
import pytest
from sqlalchemy import create_engine

@pytest.fixture(scope="session")
def postgres():
    with PostgresContainer("postgres:15") as postgres:
        yield postgres

@pytest.fixture
def db_engine(postgres):
    engine = create_engine(postgres.get_connection_url())
    Base.metadata.create_all(bind=engine)
    yield engine
    Base.metadata.drop_all(bind=engine)
```

## テスト戦略

| 層 | テスト方法 |
|----|----------|
| API | TestClient |
| Service | モック + 単体テスト |
| Repository | テストDB |
| External API | モック |

## 理解度確認

### 問題

FastAPI アプリケーションのテストで使用するクライアントはどれか。

**A.** `requests.Client`

**B.** `unittest.TestClient`

**C.** `fastapi.testclient.TestClient`

**D.** `httpx.Client`

---

### 解答・解説

**正解: C**

```python
from fastapi.testclient import TestClient
from main import app

client = TestClient(app)
response = client.get("/")
```

`fastapi.testclient.TestClient` は Starlette の TestClient をベースにしています。

---

## 次のステップ

結合テストを学びました。次は E2E テストを学びましょう。

**次の単元**: [Phase 3-2: E2E テスト](./02_E2Eテスト.md)
