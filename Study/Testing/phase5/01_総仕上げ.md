# Phase 5-1: 総仕上げ ～ 実践テスト戦略 ～

## 学習目標

この単元を終えると、以下ができるようになります：

- プロジェクトに適したテスト戦略を設計できる
- テストピラミッドを実践できる
- CI/CD にテストを組み込める

## 総合演習: タスク管理 API のテスト

### プロジェクト構成

```
task-api/
├── src/
│   ├── __init__.py
│   ├── main.py
│   ├── models.py
│   ├── schemas.py
│   ├── services/
│   │   ├── __init__.py
│   │   ├── task_service.py
│   │   └── user_service.py
│   └── repositories/
│       ├── __init__.py
│       └── task_repository.py
├── tests/
│   ├── conftest.py
│   ├── unit/
│   │   ├── test_task_service.py
│   │   └── test_user_service.py
│   ├── integration/
│   │   ├── test_api.py
│   │   └── test_repository.py
│   └── e2e/
│       └── test_flows.py
├── pyproject.toml
└── docker-compose.test.yml
```

### conftest.py

```python
# tests/conftest.py
import pytest
from fastapi.testclient import TestClient
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker

from src.main import app, get_db
from src.models import Base

# テスト用DB
TEST_DATABASE_URL = "sqlite:///./test.db"
engine = create_engine(TEST_DATABASE_URL, connect_args={"check_same_thread": False})
TestingSessionLocal = sessionmaker(bind=engine)

@pytest.fixture(scope="session")
def setup_database():
    """テストセッション開始時にテーブル作成"""
    Base.metadata.create_all(bind=engine)
    yield
    Base.metadata.drop_all(bind=engine)

@pytest.fixture
def db_session(setup_database):
    """各テストでDBセッションを提供"""
    session = TestingSessionLocal()
    try:
        yield session
    finally:
        session.rollback()
        session.close()

@pytest.fixture
def client(db_session):
    """テスト用APIクライアント"""
    def override_get_db():
        try:
            yield db_session
        finally:
            pass
    
    app.dependency_overrides[get_db] = override_get_db
    yield TestClient(app)
    app.dependency_overrides.clear()

@pytest.fixture
def auth_headers(client):
    """認証済みヘッダー"""
    response = client.post("/token", data={
        "username": "test@example.com",
        "password": "password"
    })
    token = response.json()["access_token"]
    return {"Authorization": f"Bearer {token}"}
```

### 単体テスト

```python
# tests/unit/test_task_service.py
import pytest
from unittest.mock import Mock, patch
from datetime import datetime, timedelta

from src.services.task_service import TaskService
from src.schemas import TaskCreate, TaskUpdate, TaskStatus

class TestTaskService:
    
    @pytest.fixture
    def mock_repository(self):
        return Mock()
    
    @pytest.fixture
    def service(self, mock_repository):
        return TaskService(mock_repository)
    
    def test_create_task(self, service, mock_repository):
        # Arrange
        task_data = TaskCreate(title="Test Task", description="Description")
        mock_repository.create.return_value = Mock(
            id=1, title="Test Task", status=TaskStatus.TODO
        )
        
        # Act
        result = service.create_task(task_data, user_id=1)
        
        # Assert
        mock_repository.create.assert_called_once()
        assert result.title == "Test Task"
    
    def test_complete_task(self, service, mock_repository):
        mock_task = Mock(id=1, status=TaskStatus.TODO)
        mock_repository.get.return_value = mock_task
        
        service.complete_task(task_id=1, user_id=1)
        
        assert mock_task.status == TaskStatus.DONE
        mock_repository.update.assert_called_once()
    
    def test_complete_nonexistent_task_raises(self, service, mock_repository):
        mock_repository.get.return_value = None
        
        with pytest.raises(ValueError, match="not found"):
            service.complete_task(task_id=999, user_id=1)
    
    def test_get_overdue_tasks(self, service, mock_repository):
        yesterday = datetime.now() - timedelta(days=1)
        mock_repository.get_by_due_date.return_value = [
            Mock(id=1, due_date=yesterday, status=TaskStatus.TODO)
        ]
        
        result = service.get_overdue_tasks(user_id=1)
        
        assert len(result) == 1
```

### 結合テスト

```python
# tests/integration/test_api.py
import pytest

class TestTaskAPI:
    
    def test_create_task(self, client, auth_headers):
        response = client.post(
            "/tasks",
            json={"title": "New Task", "description": "Description"},
            headers=auth_headers
        )
        
        assert response.status_code == 201
        data = response.json()
        assert data["title"] == "New Task"
        assert data["status"] == "todo"
    
    def test_get_task(self, client, auth_headers):
        # Create
        create_response = client.post(
            "/tasks",
            json={"title": "Task"},
            headers=auth_headers
        )
        task_id = create_response.json()["id"]
        
        # Get
        response = client.get(f"/tasks/{task_id}", headers=auth_headers)
        
        assert response.status_code == 200
        assert response.json()["id"] == task_id
    
    def test_update_task_status(self, client, auth_headers):
        # Create
        create_response = client.post(
            "/tasks",
            json={"title": "Task"},
            headers=auth_headers
        )
        task_id = create_response.json()["id"]
        
        # Update
        response = client.patch(
            f"/tasks/{task_id}",
            json={"status": "done"},
            headers=auth_headers
        )
        
        assert response.status_code == 200
        assert response.json()["status"] == "done"
    
    def test_unauthorized_access(self, client):
        response = client.get("/tasks")
        assert response.status_code == 401
```

```python
# tests/integration/test_repository.py
import pytest
from src.repositories.task_repository import TaskRepository
from src.models import Task

class TestTaskRepository:
    
    def test_create_and_get(self, db_session):
        repo = TaskRepository(db_session)
        
        task = repo.create(
            title="Test",
            description="Desc",
            user_id=1
        )
        
        found = repo.get(task.id)
        
        assert found is not None
        assert found.title == "Test"
    
    def test_list_by_user(self, db_session):
        repo = TaskRepository(db_session)
        
        repo.create(title="Task 1", user_id=1)
        repo.create(title="Task 2", user_id=1)
        repo.create(title="Other User Task", user_id=2)
        
        tasks = repo.list_by_user(user_id=1)
        
        assert len(tasks) == 2
        assert all(t.user_id == 1 for t in tasks)
```

### E2E テスト

```python
# tests/e2e/test_flows.py
import pytest

class TestTaskManagementFlow:
    """タスク管理の完全なフロー"""
    
    def test_complete_task_workflow(self, client, auth_headers):
        # 1. タスク作成
        create_response = client.post(
            "/tasks",
            json={
                "title": "Complete E2E Flow",
                "description": "This is an E2E test",
                "due_date": "2024-12-31"
            },
            headers=auth_headers
        )
        assert create_response.status_code == 201
        task_id = create_response.json()["id"]
        
        # 2. タスク一覧で確認
        list_response = client.get("/tasks", headers=auth_headers)
        assert any(t["id"] == task_id for t in list_response.json())
        
        # 3. タスク更新
        update_response = client.patch(
            f"/tasks/{task_id}",
            json={"status": "in_progress"},
            headers=auth_headers
        )
        assert update_response.status_code == 200
        
        # 4. タスク完了
        complete_response = client.patch(
            f"/tasks/{task_id}",
            json={"status": "done"},
            headers=auth_headers
        )
        assert complete_response.status_code == 200
        assert complete_response.json()["status"] == "done"
        
        # 5. 完了タスクをフィルタ
        filter_response = client.get(
            "/tasks?status=done",
            headers=auth_headers
        )
        assert any(t["id"] == task_id for t in filter_response.json())
```

### CI 設定

```yaml
# .github/workflows/test.yml
name: Tests

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  unit-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      - name: Install dependencies
        run: pip install -r requirements-dev.txt
      - name: Run unit tests
        run: pytest tests/unit -v --cov=src --cov-fail-under=80

  integration-tests:
    runs-on: ubuntu-latest
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_DB: test
        ports:
          - 5432:5432
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.12'
      - name: Install dependencies
        run: pip install -r requirements-dev.txt
      - name: Run integration tests
        run: pytest tests/integration -v
        env:
          DATABASE_URL: postgresql://postgres:test@localhost/test

  e2e-tests:
    runs-on: ubuntu-latest
    needs: [unit-tests, integration-tests]
    steps:
      - uses: actions/checkout@v4
      - name: Start services
        run: docker-compose -f docker-compose.test.yml up -d
      - name: Run E2E tests
        run: pytest tests/e2e -v
```

## テスト戦略チェックリスト

```markdown
## 単体テスト
- [ ] ビジネスロジックをカバー
- [ ] 外部依存をモック化
- [ ] 境界値・エッジケース
- [ ] カバレッジ80%以上

## 結合テスト
- [ ] API エンドポイント
- [ ] データベース連携
- [ ] 認証・認可

## E2E テスト
- [ ] 重要なユーザーフロー
- [ ] ハッピーパス
- [ ] 主要なエラーケース

## CI/CD
- [ ] PRでテスト自動実行
- [ ] カバレッジレポート
- [ ] テスト失敗でマージブロック
```

## カリキュラム完了！

おめでとうございます！テスト戦略・品質保証のカリキュラムを完了しました。

### 学んだこと

1. **テスト基礎** - テストピラミッド、FIRST原則
2. **pytest** - フィクスチャ、パラメータ化
3. **単体テスト** - ロジックテスト、境界値
4. **モック** - unittest.mock、依存の分離
5. **結合テスト** - API テスト、DB テスト
6. **E2E テスト** - Playwright、ユーザーフロー
7. **TDD** - Red-Green-Refactor
8. **カバレッジ** - 計測と目標設定

### 次のステップ

- **Property-based testing** - Hypothesis
- **Mutation testing** - mutmut
- **Performance testing** - locust
- **Contract testing** - Pact
