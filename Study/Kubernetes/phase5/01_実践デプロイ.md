# Phase 5-1: 実践デプロイ

## 学習目標

この単元を終えると、以下ができるようになります：

- 実際のアプリケーションを Kubernetes にデプロイできる
- マニフェストを環境ごとに管理できる
- ヘルスチェック・リソース制限を適切に設定できる

## ハンズオン

### プロジェクト: Flask アプリ + MySQL

```
k8s-app/
├── app/
│   ├── Dockerfile
│   └── app.py
├── k8s/
│   ├── namespace.yaml
│   ├── configmap.yaml
│   ├── secret.yaml
│   ├── mysql/
│   │   ├── statefulset.yaml
│   │   └── service.yaml
│   └── flask/
│       ├── deployment.yaml
│       ├── service.yaml
│       └── ingress.yaml
└── kustomize/
    ├── base/
    └── overlays/
        ├── dev/
        └── prod/
```

### 演習1: アプリケーション作成

```python
# app/app.py
from flask import Flask, jsonify
import os
import mysql.connector

app = Flask(__name__)

def get_db_connection():
    return mysql.connector.connect(
        host=os.environ.get('DB_HOST', 'mysql'),
        user=os.environ.get('DB_USER', 'root'),
        password=os.environ.get('DB_PASSWORD', ''),
        database=os.environ.get('DB_NAME', 'app')
    )

@app.route('/health')
def health():
    return jsonify({"status": "healthy"})

@app.route('/ready')
def ready():
    try:
        conn = get_db_connection()
        conn.close()
        return jsonify({"status": "ready"})
    except Exception as e:
        return jsonify({"status": "not ready", "error": str(e)}), 503

@app.route('/')
def index():
    return jsonify({
        "message": "Hello from Kubernetes!",
        "env": os.environ.get('APP_ENV', 'unknown')
    })

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
```

```dockerfile
# app/Dockerfile
FROM python:3.11-slim

WORKDIR /app

RUN pip install flask mysql-connector-python

COPY app.py .

EXPOSE 5000

CMD ["python", "app.py"]
```

```bash
# イメージビルド（minikubeのDockerデーモンを使用）
eval $(minikube docker-env)
docker build -t flask-app:v1 ./app
```

### 演習2: Namespace

```yaml
# k8s/namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: myapp
  labels:
    app: myapp
```

### 演習3: ConfigMap と Secret

```yaml
# k8s/configmap.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: app-config
  namespace: myapp
data:
  APP_ENV: "production"
  DB_HOST: "mysql.myapp.svc.cluster.local"
  DB_NAME: "app"
```

```yaml
# k8s/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
  namespace: myapp
type: Opaque
stringData:
  DB_USER: appuser
  DB_PASSWORD: SecurePassword123
  MYSQL_ROOT_PASSWORD: RootPassword123
```

### 演習4: MySQL StatefulSet

```yaml
# k8s/mysql/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: mysql
  namespace: myapp
spec:
  serviceName: mysql
  replicas: 1
  selector:
    matchLabels:
      app: mysql
  template:
    metadata:
      labels:
        app: mysql
    spec:
      containers:
      - name: mysql
        image: mysql:8.0
        ports:
        - containerPort: 3306
        env:
        - name: MYSQL_ROOT_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: MYSQL_ROOT_PASSWORD
        - name: MYSQL_DATABASE
          valueFrom:
            configMapKeyRef:
              name: app-config
              key: DB_NAME
        - name: MYSQL_USER
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: DB_USER
        - name: MYSQL_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: DB_PASSWORD
        resources:
          requests:
            cpu: 250m
            memory: 512Mi
          limits:
            cpu: 500m
            memory: 1Gi
        livenessProbe:
          exec:
            command: ["mysqladmin", "ping", "-h", "localhost"]
          initialDelaySeconds: 30
          periodSeconds: 10
        readinessProbe:
          exec:
            command: ["mysql", "-h", "localhost", "-e", "SELECT 1"]
          initialDelaySeconds: 10
          periodSeconds: 5
        volumeMounts:
        - name: data
          mountPath: /var/lib/mysql
  volumeClaimTemplates:
  - metadata:
      name: data
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 1Gi
```

```yaml
# k8s/mysql/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: mysql
  namespace: myapp
spec:
  clusterIP: None  # Headless Service
  selector:
    app: mysql
  ports:
  - port: 3306
```

### 演習5: Flask Deployment

```yaml
# k8s/flask/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: flask-app
  namespace: myapp
spec:
  replicas: 3
  selector:
    matchLabels:
      app: flask
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1
      maxUnavailable: 1
  template:
    metadata:
      labels:
        app: flask
    spec:
      containers:
      - name: flask
        image: flask-app:v1
        imagePullPolicy: Never  # ローカルイメージを使用
        ports:
        - containerPort: 5000
        envFrom:
        - configMapRef:
            name: app-config
        - secretRef:
            name: db-secret
        resources:
          requests:
            cpu: 100m
            memory: 128Mi
          limits:
            cpu: 200m
            memory: 256Mi
        livenessProbe:
          httpGet:
            path: /health
            port: 5000
          initialDelaySeconds: 10
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /ready
            port: 5000
          initialDelaySeconds: 5
          periodSeconds: 5
```

```yaml
# k8s/flask/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: flask-service
  namespace: myapp
spec:
  selector:
    app: flask
  ports:
  - port: 80
    targetPort: 5000
```

```yaml
# k8s/flask/ingress.yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: flask-ingress
  namespace: myapp
spec:
  ingressClassName: nginx
  rules:
  - host: myapp.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: flask-service
            port:
              number: 80
```

### 演習6: デプロイ実行

```bash
# 順番にデプロイ
kubectl apply -f k8s/namespace.yaml
kubectl apply -f k8s/configmap.yaml
kubectl apply -f k8s/secret.yaml
kubectl apply -f k8s/mysql/
kubectl apply -f k8s/flask/

# 確認
kubectl get all -n myapp
kubectl get pvc -n myapp
kubectl get ingress -n myapp

# ホスト設定
echo "$(minikube ip) myapp.local" | sudo tee -a /etc/hosts

# アクセス
curl http://myapp.local/
curl http://myapp.local/health
curl http://myapp.local/ready
```

### 演習7: Kustomize による環境管理

```yaml
# kustomize/base/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

resources:
  - ../k8s/namespace.yaml
  - ../k8s/configmap.yaml
  - ../k8s/mysql/
  - ../k8s/flask/
```

```yaml
# kustomize/overlays/dev/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

namespace: myapp-dev

resources:
  - ../../base

patches:
  - target:
      kind: Deployment
      name: flask-app
    patch: |-
      - op: replace
        path: /spec/replicas
        value: 1

configMapGenerator:
  - name: app-config
    behavior: merge
    literals:
      - APP_ENV=development
```

```yaml
# kustomize/overlays/prod/kustomization.yaml
apiVersion: kustomize.config.k8s.io/v1beta1
kind: Kustomization

namespace: myapp-prod

resources:
  - ../../base

patches:
  - target:
      kind: Deployment
      name: flask-app
    patch: |-
      - op: replace
        path: /spec/replicas
        value: 5

configMapGenerator:
  - name: app-config
    behavior: merge
    literals:
      - APP_ENV=production
```

```bash
# dev 環境をデプロイ
kubectl apply -k kustomize/overlays/dev/

# prod 環境をデプロイ
kubectl apply -k kustomize/overlays/prod/
```

## 本番運用チェックリスト

```markdown
## リソース設定
- [ ] requests/limits を設定
- [ ] HPA を設定（必要に応じて）

## ヘルスチェック
- [ ] livenessProbe を設定
- [ ] readinessProbe を設定
- [ ] startupProbe を設定（起動が遅い場合）

## セキュリティ
- [ ] Secret で機密情報を管理
- [ ] NetworkPolicy を設定
- [ ] SecurityContext を設定

## 可用性
- [ ] replicas >= 2
- [ ] PodDisruptionBudget を設定
- [ ] アンチアフィニティを設定
```

## 理解度確認

### 問題

本番環境で Flask アプリの Pod を更新する際、ダウンタイムを最小限にするために必要な設定はどれか。（複数選択）

**A.** readinessProbe の設定

**B.** replicas: 1

**C.** RollingUpdate 戦略

**D.** maxUnavailable: 0 はNG

---

### 解答・解説

**正解: A, C**

- **A.** readinessProbe がないと、起動中の Pod にトラフィックが流れる
- **C.** RollingUpdate で段階的に更新
- B は NG（1 Pod だとダウンタイムが発生）
- D は正しい（maxUnavailable: 0 だと更新が進まない）

---

## 次のステップ

実践デプロイを学びました。次は総仕上げとしてマイクロサービスを構築しましょう。

**次の単元**: [Phase 6-1: 総仕上げ](../phase6/01_総仕上げ.md)
