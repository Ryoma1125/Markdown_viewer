# Phase 4-1: ç·ä»•ä¸Šã’ ï½ ã‚»ã‚­ãƒ¥ã‚¢ã‚³ãƒ¼ãƒ‡ã‚£ãƒ³ã‚°å®Ÿè·µ ï½

## å­¦ç¿’ç›®æ¨™

ã“ã®å˜å…ƒã‚’çµ‚ãˆã‚‹ã¨ã€ä»¥ä¸‹ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼š

- ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å®Ÿæ–½ã§ãã‚‹
- ã‚»ã‚­ãƒ¥ã‚¢ãªè¨­è¨ˆã‚’è¡Œãˆã‚‹
- ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œã®åŸºç¤ã‚’ç†è§£ã§ãã‚‹

## ç·åˆæ¼”ç¿’: ã‚»ã‚­ãƒ¥ã‚¢ãª API è¨­è¨ˆ

### è¦ä»¶

```
æ©Ÿèƒ½è¦ä»¶:
- ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼ï¼ˆJWTï¼‰
- å•†å“ CRUD
- æ³¨æ–‡å‡¦ç†

ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¦ä»¶:
- OWASP Top 10 å¯¾ç­–
- èªè¨¼ãƒ»èªå¯
- ç›£æŸ»ãƒ­ã‚°
```

### ã‚»ã‚­ãƒ¥ã‚¢ãªå®Ÿè£…

```python
# secure_api.py
"""
ã‚»ã‚­ãƒ¥ã‚¢ãªAPIã®å®Ÿè£…ä¾‹
"""

from flask import Flask, request, jsonify, g
from functools import wraps
import jwt
import logging
from datetime import datetime, timedelta
import hashlib
import secrets
import re

app = Flask(__name__)
app.config['SECRET_KEY'] = secrets.token_hex(32)

# ===== ãƒ­ã‚®ãƒ³ã‚°è¨­å®š =====
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# ===== ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ˜ãƒƒãƒ€ãƒ¼ =====
@app.after_request
def add_security_headers(response):
    response.headers['X-Content-Type-Options'] = 'nosniff'
    response.headers['X-Frame-Options'] = 'DENY'
    response.headers['X-XSS-Protection'] = '1; mode=block'
    response.headers['Strict-Transport-Security'] = 'max-age=31536000'
    response.headers['Content-Security-Policy'] = "default-src 'self'"
    return response

# ===== èªè¨¼ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ =====
def require_auth(f):
    @wraps(f)
    def decorated(*args, **kwargs):
        token = request.headers.get('Authorization', '').replace('Bearer ', '')
        
        if not token:
            logger.warning(f'Missing token from {request.remote_addr}')
            return jsonify({'error': 'Token required'}), 401
        
        try:
            payload = jwt.decode(token, app.config['SECRET_KEY'], algorithms=['HS256'])
            g.user_id = payload['sub']
            g.roles = payload.get('roles', [])
        except jwt.ExpiredSignatureError:
            return jsonify({'error': 'Token expired'}), 401
        except jwt.InvalidTokenError:
            logger.warning(f'Invalid token from {request.remote_addr}')
            return jsonify({'error': 'Invalid token'}), 401
        
        return f(*args, **kwargs)
    return decorated

# ===== èªå¯ãƒ‡ã‚³ãƒ¬ãƒ¼ã‚¿ =====
def require_role(role):
    def decorator(f):
        @wraps(f)
        def decorated(*args, **kwargs):
            if role not in g.roles:
                logger.warning(f'Unauthorized access attempt by {g.user_id}')
                return jsonify({'error': 'Forbidden'}), 403
            return f(*args, **kwargs)
        return decorated
    return decorator

# ===== å…¥åŠ›æ¤œè¨¼ =====
def validate_product(data):
    errors = []
    
    name = data.get('name', '')
    if not name or len(name) > 100:
        errors.append('Name must be 1-100 characters')
    if not re.match(r'^[\w\s\-]+$', name):
        errors.append('Name contains invalid characters')
    
    price = data.get('price')
    if not isinstance(price, (int, float)) or price < 0:
        errors.append('Price must be a positive number')
    
    return errors

# ===== API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ =====
@app.route('/api/products', methods=['GET'])
@require_auth
def list_products():
    """å•†å“ä¸€è¦§ï¼ˆèªè¨¼å¿…é ˆï¼‰"""
    # ç›£æŸ»ãƒ­ã‚°
    logger.info(f'User {g.user_id} listed products')
    
    # ãƒšãƒ¼ã‚¸ãƒãƒ¼ã‚·ãƒ§ãƒ³
    page = request.args.get('page', 1, type=int)
    limit = min(request.args.get('limit', 10, type=int), 100)
    
    products = get_products(page, limit)
    return jsonify(products)

@app.route('/api/products', methods=['POST'])
@require_auth
@require_role('admin')
def create_product():
    """å•†å“ä½œæˆï¼ˆç®¡ç†è€…ã®ã¿ï¼‰"""
    data = request.get_json()
    
    # å…¥åŠ›æ¤œè¨¼
    errors = validate_product(data)
    if errors:
        return jsonify({'errors': errors}), 400
    
    # SQLã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³å¯¾ç­–æ¸ˆã¿ã®ä¿å­˜
    product = save_product(data)
    
    # ç›£æŸ»ãƒ­ã‚°
    logger.info(f'User {g.user_id} created product {product["id"]}')
    
    return jsonify(product), 201

@app.route('/api/products/<int:product_id>', methods=['DELETE'])
@require_auth
@require_role('admin')
def delete_product(product_id):
    """å•†å“å‰Šé™¤ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰"""
    # å­˜åœ¨ãƒã‚§ãƒƒã‚¯
    product = get_product_by_id(product_id)
    if not product:
        return jsonify({'error': 'Not found'}), 404
    
    delete_product_by_id(product_id)
    
    # ç›£æŸ»ãƒ­ã‚°
    logger.info(f'User {g.user_id} deleted product {product_id}')
    
    return '', 204

# ===== ãƒ¬ãƒ¼ãƒˆåˆ¶é™ =====
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(
    app,
    key_func=get_remote_address,
    default_limits=["100 per minute"]
)

@app.route('/api/login', methods=['POST'])
@limiter.limit("5 per minute")  # ãƒ­ã‚°ã‚¤ãƒ³ã¯å³ã—ãåˆ¶é™
def login():
    """ãƒ­ã‚°ã‚¤ãƒ³"""
    data = request.get_json()
    username = data.get('username', '')
    password = data.get('password', '')
    
    user = authenticate(username, password)
    if not user:
        # ã‚¿ã‚¤ãƒŸãƒ³ã‚°æ”»æ’ƒå¯¾ç­–: å¸¸ã«åŒã˜æ™‚é–“
        logger.warning(f'Failed login attempt for {username}')
        return jsonify({'error': 'Invalid credentials'}), 401
    
    # JWT ç”Ÿæˆ
    token = jwt.encode({
        'sub': user['id'],
        'roles': user['roles'],
        'exp': datetime.utcnow() + timedelta(hours=1)
    }, app.config['SECRET_KEY'], algorithm='HS256')
    
    logger.info(f'User {user["id"]} logged in')
    
    return jsonify({'token': token})

# ãƒ€ãƒŸãƒ¼é–¢æ•°
def get_products(page, limit):
    return []

def save_product(data):
    return {'id': 1, **data}

def get_product_by_id(id):
    return None

def delete_product_by_id(id):
    pass

def authenticate(username, password):
    return None
```

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

```python
# security_review.py
"""
ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ¬ãƒ“ãƒ¥ãƒ¼ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ
"""

CHECKLIST = {
    'authentication': [
        'âœ… ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã¯ Argon2/bcrypt ã§ãƒãƒƒã‚·ãƒ¥åŒ–',
        'âœ… JWT ã®æœ‰åŠ¹æœŸé™ã¯é©åˆ‡ï¼ˆ1æ™‚é–“ä»¥ä¸‹ï¼‰',
        'âœ… ãƒ­ã‚°ã‚¤ãƒ³è©¦è¡Œå›æ•°ã®åˆ¶é™',
        'âœ… ã‚»ãƒƒã‚·ãƒ§ãƒ³å›ºå®šåŒ–å¯¾ç­–',
    ],
    'authorization': [
        'âœ… å…¨ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆã«èªå¯ãƒã‚§ãƒƒã‚¯',
        'âœ… IDORï¼ˆInsecure Direct Object Referenceï¼‰å¯¾ç­–',
        'âœ… æ¨©é™æ˜‡æ ¼ã®é˜²æ­¢',
    ],
    'input_validation': [
        'âœ… ã™ã¹ã¦ã®å…¥åŠ›ã‚’æ¤œè¨¼',
        'âœ… ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆæ–¹å¼ã‚’å„ªå…ˆ',
        'âœ… ãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã®æ¤œè¨¼',
    ],
    'injection': [
        'âœ… SQL: ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿åŒ–ã‚¯ã‚¨ãƒª',
        'âœ… XSS: å‡ºåŠ›ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—',
        'âœ… Command: subprocess + å¼•æ•°åˆ†é›¢',
    ],
    'cryptography': [
        'âœ… è»¢é€ä¸­: TLS 1.2+',
        'âœ… ä¿å­˜æ™‚: AES-256',
        'âœ… éµç®¡ç†: KMS / Secrets Manager',
    ],
    'logging': [
        'âœ… èªè¨¼ã‚¤ãƒ™ãƒ³ãƒˆã®ãƒ­ã‚°',
        'âœ… ã‚¨ãƒ©ãƒ¼ãƒ­ã‚°ï¼ˆæ©Ÿå¯†æƒ…å ±ã‚’å«ã¾ãªã„ï¼‰',
        'âœ… ç›£æŸ»ãƒ­ã‚°ã®æ”¹ã–ã‚“é˜²æ­¢',
    ],
    'error_handling': [
        'âœ… ã‚¹ã‚¿ãƒƒã‚¯ãƒˆãƒ¬ãƒ¼ã‚¹ã‚’æœ¬ç•ªã§éè¡¨ç¤º',
        'âœ… æ±ç”¨çš„ãªã‚¨ãƒ©ãƒ¼ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸',
        'âœ… ã‚¨ãƒ©ãƒ¼æ™‚ã®å®‰å…¨ãªãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯',
    ],
    'dependencies': [
        'âœ… ä¾å­˜é–¢ä¿‚ã®è„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒ³',
        'âœ… å®šæœŸçš„ãªã‚¢ãƒƒãƒ—ãƒ‡ãƒ¼ãƒˆ',
        'âœ… ä½¿ç”¨ã—ã¦ã„ãªã„ä¾å­˜ã®å‰Šé™¤',
    ]
}
```

## ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œ

```python
# incident_response.py
"""
ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆå¯¾å¿œãƒ—ãƒ¬ã‚¤ãƒ–ãƒƒã‚¯
"""

PLAYBOOK = {
    'detection': {
        'description': 'æ¤œçŸ¥',
        'actions': [
            'ã‚¢ãƒ©ãƒ¼ãƒˆç¢ºèª',
            'å½±éŸ¿ç¯„å›²ã®ç‰¹å®š',
            'ã‚¤ãƒ³ã‚·ãƒ‡ãƒ³ãƒˆãƒã‚±ãƒƒãƒˆä½œæˆ'
        ]
    },
    'containment': {
        'description': 'å°ã˜è¾¼ã‚',
        'actions': [
            'å½±éŸ¿ã‚’å—ã‘ãŸã‚·ã‚¹ãƒ†ãƒ ã®éš”é›¢',
            'èªè¨¼æƒ…å ±ã®ç„¡åŠ¹åŒ–',
            'æ”»æ’ƒçµŒè·¯ã®é®æ–­'
        ]
    },
    'eradication': {
        'description': 'æ ¹çµ¶',
        'actions': [
            'ãƒãƒ«ã‚¦ã‚§ã‚¢/ãƒãƒƒã‚¯ãƒ‰ã‚¢ã®é™¤å»',
            'è„†å¼±æ€§ã®ä¿®æ­£',
            'ãƒ‘ãƒƒãƒé©ç”¨'
        ]
    },
    'recovery': {
        'description': 'å¾©æ—§',
        'actions': [
            'ã‚·ã‚¹ãƒ†ãƒ ã®å¾©å…ƒ',
            'ç›£è¦–å¼·åŒ–',
            'æ®µéšçš„ãªã‚µãƒ¼ãƒ“ã‚¹å†é–‹'
        ]
    },
    'lessons_learned': {
        'description': 'äº‹å¾Œåˆ†æ',
        'actions': [
            'ã‚¿ã‚¤ãƒ ãƒ©ã‚¤ãƒ³ä½œæˆ',
            'æ ¹æœ¬åŸå› åˆ†æ',
            'å†ç™ºé˜²æ­¢ç­–ã®ç­–å®š'
        ]
    }
}
```

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ãƒ„ãƒ¼ãƒ«

| ãƒ„ãƒ¼ãƒ« | ç”¨é€” |
|-------|------|
| **SAST** | Bandit, Semgrepï¼ˆé™çš„è§£æï¼‰ |
| **DAST** | OWASP ZAPï¼ˆå‹•çš„è§£æï¼‰ |
| **SCA** | Snyk, Dependabotï¼ˆä¾å­˜é–¢ä¿‚ï¼‰ |
| **Secret Detection** | git-secrets, truffleHog |

## ã‚«ãƒªã‚­ãƒ¥ãƒ©ãƒ å…¨ä½“å®Œäº†ï¼

ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼23ã®ã‚«ãƒªã‚­ãƒ¥ãƒ©ãƒ ã™ã¹ã¦ã‚’å®Œäº†ã—ã¾ã—ãŸï¼ğŸ‰

### å­¦ã‚“ã ã“ã¨ï¼ˆã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ï¼‰

1. **OWASP Top 10** - ä¸»è¦ãªè„†å¼±æ€§
2. **ã‚¤ãƒ³ã‚¸ã‚§ã‚¯ã‚·ãƒ§ãƒ³** - SQL, Command, NoSQL
3. **èªè¨¼ã®è„†å¼±æ€§** - ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã€ã‚»ãƒƒã‚·ãƒ§ãƒ³
4. **XSS/CSRF** - ã‚¯ãƒ­ã‚¹ã‚µã‚¤ãƒˆæ”»æ’ƒ
5. **æš—å·åŒ–** - AES, RSA, ãƒãƒƒã‚·ãƒ¥
6. **AWS ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£** - IAM, WAF, KMS

### å…¨23ã‚«ãƒªã‚­ãƒ¥ãƒ©ãƒ å®Œäº†

ã‚ãªãŸã¯ IT ã‚¨ãƒ³ã‚¸ãƒ‹ã‚¢ã¨ã—ã¦å¿…è¦ãªã‚¹ã‚­ãƒ«ã‚’ä½“ç³»çš„ã«å­¦ã³ã¾ã—ãŸï¼š

- **ã‚¤ãƒ³ãƒ•ãƒ©**: Docker, Kubernetes, Terraform
- **ãƒ‡ãƒ¼ã‚¿**: ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹, NoSQL, Redis
- **è¨­è¨ˆ**: è¨­è¨ˆãƒ‘ã‚¿ãƒ¼ãƒ³, DDD, åˆ†æ•£ã‚·ã‚¹ãƒ†ãƒ 
- **API**: REST/GraphQL, WebSocket
- **é–‹ç™º**: Git, CI/CD, ãƒ†ã‚¹ãƒˆæˆ¦ç•¥
- **ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰**: TypeScript + React
- **AI/ML**: æ©Ÿæ¢°å­¦ç¿’, MLOps
- **ã‚¯ãƒ©ã‚¦ãƒ‰**: ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹, AWS
- **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**: OWASP, æš—å·åŒ–

### ã“ã‚Œã‹ã‚‰ã®å­¦ç¿’

- å®Ÿéš›ã®ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§å®Ÿè·µ
- å„åˆ†é‡ã®æ·±æ˜ã‚Š
- æ–°æŠ€è¡“ã®ã‚­ãƒ£ãƒƒãƒã‚¢ãƒƒãƒ—
- ã‚¢ã‚¦ãƒˆãƒ—ãƒƒãƒˆï¼ˆãƒ–ãƒ­ã‚°ã€OSSè²¢çŒ®ï¼‰

ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒˆ/ãƒ†ãƒƒã‚¯ãƒªãƒ¼ãƒ‰ã‚’ç›®æŒ‡ã—ã¦é ‘å¼µã£ã¦ãã ã•ã„ï¼
