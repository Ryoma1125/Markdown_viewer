# Phase 5-1: 総仕上げ ～ DDD 実践プロジェクト ～

## 学習目標

この単元を終えると、以下ができるようになります：

- DDD プロジェクトの構成を設計できる
- 戦略的・戦術的設計を実践できる
- チームへ DDD を導入できる

## 総合演習: 予約システム

### 要件分析

```
ビジネス要件:
- 会議室の予約管理
- 予約の作成・変更・キャンセル
- 予約の重複防止
- 利用者の権限管理

発見したコンテキスト:
1. 予約コンテキスト（Core）
2. 施設コンテキスト（Supporting）
3. ユーザー管理コンテキスト（Generic）
4. 通知コンテキスト（Generic）
```

### プロジェクト構成

```
reservation_system/
├── src/
│   ├── reservation/           # 予約コンテキスト（Core）
│   │   ├── domain/
│   │   │   ├── model/
│   │   │   │   ├── reservation.py
│   │   │   │   ├── time_slot.py
│   │   │   │   └── reservation_policy.py
│   │   │   ├── repository.py
│   │   │   └── service.py
│   │   ├── application/
│   │   │   ├── commands.py
│   │   │   └── use_cases.py
│   │   └── infrastructure/
│   │       └── persistence.py
│   │
│   ├── facility/              # 施設コンテキスト
│   │   ├── domain/
│   │   └── infrastructure/
│   │
│   └── shared/                # 共有カーネル
│       └── value_objects.py
│
└── tests/
```

### ドメインモデル実装

```python
# src/reservation/domain/model/reservation.py
from dataclasses import dataclass
from typing import List, Optional
from datetime import datetime, timedelta
from enum import Enum
import uuid

# 値オブジェクト
@dataclass(frozen=True)
class ReservationId:
    value: str
    
    @classmethod
    def generate(cls) -> 'ReservationId':
        return cls(str(uuid.uuid4()))

@dataclass(frozen=True)
class TimeSlot:
    """時間枠（値オブジェクト）"""
    start: datetime
    end: datetime
    
    def __post_init__(self):
        if self.start >= self.end:
            raise ValueError('開始時刻は終了時刻より前である必要があります')
        
        duration = (self.end - self.start).total_seconds() / 60
        if duration < 15:
            raise ValueError('予約は最低15分以上')
        if duration > 480:
            raise ValueError('予約は最大8時間まで')
    
    def overlaps(self, other: 'TimeSlot') -> bool:
        """時間枠が重複するか"""
        return self.start < other.end and other.start < self.end
    
    @property
    def duration_minutes(self) -> int:
        return int((self.end - self.start).total_seconds() / 60)

class ReservationStatus(Enum):
    PENDING = 'pending'
    CONFIRMED = 'confirmed'
    CANCELLED = 'cancelled'

# 集約ルート
class Reservation:
    """予約集約"""
    
    def __init__(
        self,
        reservation_id: ReservationId,
        room_id: str,
        organizer_id: str,
        time_slot: TimeSlot,
        title: str
    ):
        self._reservation_id = reservation_id
        self._room_id = room_id
        self._organizer_id = organizer_id
        self._time_slot = time_slot
        self._title = title
        self._attendees: List[str] = [organizer_id]
        self._status = ReservationStatus.PENDING
        self._created_at = datetime.now()
        self._events = []
    
    @property
    def reservation_id(self) -> ReservationId:
        return self._reservation_id
    
    @property
    def room_id(self) -> str:
        return self._room_id
    
    @property
    def time_slot(self) -> TimeSlot:
        return self._time_slot
    
    @property
    def is_active(self) -> bool:
        return self._status != ReservationStatus.CANCELLED
    
    def add_attendee(self, user_id: str):
        """参加者を追加"""
        if len(self._attendees) >= 50:
            raise ReservationError('参加者は50名まで')
        if user_id in self._attendees:
            raise ReservationError('すでに参加者です')
        
        self._attendees.append(user_id)
    
    def remove_attendee(self, user_id: str):
        """参加者を削除"""
        if user_id == self._organizer_id:
            raise ReservationError('主催者は削除できません')
        if user_id not in self._attendees:
            raise ReservationError('参加者ではありません')
        
        self._attendees.remove(user_id)
    
    def reschedule(self, new_time_slot: TimeSlot, conflict_checker: 'ConflictChecker'):
        """予約時間を変更"""
        if self._status == ReservationStatus.CANCELLED:
            raise ReservationError('キャンセル済みの予約は変更できません')
        
        # 重複チェック（ドメインサービスを使用）
        if conflict_checker.has_conflict(self._room_id, new_time_slot, self._reservation_id):
            raise ReservationError('指定時間には既に予約があります')
        
        self._time_slot = new_time_slot
        self._events.append(ReservationRescheduled(
            reservation_id=self._reservation_id.value,
            new_start=new_time_slot.start,
            new_end=new_time_slot.end
        ))
    
    def confirm(self):
        """予約を確定"""
        if self._status != ReservationStatus.PENDING:
            raise ReservationError('確定できる状態ではありません')
        
        self._status = ReservationStatus.CONFIRMED
        self._events.append(ReservationConfirmed(
            reservation_id=self._reservation_id.value,
            room_id=self._room_id,
            organizer_id=self._organizer_id
        ))
    
    def cancel(self, cancelled_by: str):
        """予約をキャンセル"""
        if self._status == ReservationStatus.CANCELLED:
            raise ReservationError('すでにキャンセル済みです')
        
        # 開始1時間前を過ぎたらキャンセル不可
        if datetime.now() > self._time_slot.start - timedelta(hours=1):
            raise ReservationError('開始1時間前を過ぎるとキャンセルできません')
        
        self._status = ReservationStatus.CANCELLED
        self._events.append(ReservationCancelled(
            reservation_id=self._reservation_id.value,
            cancelled_by=cancelled_by
        ))
    
    def get_domain_events(self):
        events = self._events.copy()
        self._events.clear()
        return events

class ReservationError(Exception):
    pass

# ドメインイベント
@dataclass
class ReservationConfirmed:
    reservation_id: str
    room_id: str
    organizer_id: str

@dataclass
class ReservationCancelled:
    reservation_id: str
    cancelled_by: str

@dataclass
class ReservationRescheduled:
    reservation_id: str
    new_start: datetime
    new_end: datetime
```

```python
# src/reservation/domain/service.py
from abc import ABC, abstractmethod

class ConflictChecker(ABC):
    """予約重複チェック（ドメインサービス）"""
    
    @abstractmethod
    def has_conflict(
        self,
        room_id: str,
        time_slot: TimeSlot,
        exclude_reservation_id: ReservationId = None
    ) -> bool:
        pass

class ReservationConflictChecker(ConflictChecker):
    def __init__(self, reservation_repo: 'ReservationRepository'):
        self.reservation_repo = reservation_repo
    
    def has_conflict(
        self,
        room_id: str,
        time_slot: TimeSlot,
        exclude_reservation_id: ReservationId = None
    ) -> bool:
        existing = self.reservation_repo.find_by_room_and_date(
            room_id,
            time_slot.start.date()
        )
        
        for reservation in existing:
            if exclude_reservation_id and reservation.reservation_id == exclude_reservation_id:
                continue
            if not reservation.is_active:
                continue
            if reservation.time_slot.overlaps(time_slot):
                return True
        
        return False
```

```python
# src/reservation/application/use_cases.py
from dataclasses import dataclass

@dataclass
class CreateReservationCommand:
    room_id: str
    organizer_id: str
    start: datetime
    end: datetime
    title: str

class CreateReservationUseCase:
    def __init__(
        self,
        reservation_repo: ReservationRepository,
        conflict_checker: ConflictChecker,
        event_publisher: EventPublisher
    ):
        self.reservation_repo = reservation_repo
        self.conflict_checker = conflict_checker
        self.event_publisher = event_publisher
    
    def execute(self, command: CreateReservationCommand) -> str:
        time_slot = TimeSlot(command.start, command.end)
        
        # 重複チェック
        if self.conflict_checker.has_conflict(command.room_id, time_slot):
            raise ApplicationError('指定時間には既に予約があります')
        
        # 予約作成
        reservation = Reservation(
            reservation_id=self.reservation_repo.next_id(),
            room_id=command.room_id,
            organizer_id=command.organizer_id,
            time_slot=time_slot,
            title=command.title
        )
        
        reservation.confirm()
        
        # 保存
        self.reservation_repo.save(reservation)
        
        # イベント発行
        for event in reservation.get_domain_events():
            self.event_publisher.publish(event)
        
        return reservation.reservation_id.value
```

## DDD 導入チェックリスト

### 準備

- [ ] ドメインエキスパートの協力を得る
- [ ] コアドメインを特定する
- [ ] ユビキタス言語を定義する

### 設計

- [ ] 境界づけられたコンテキストを識別
- [ ] コンテキストマップを作成
- [ ] 集約を設計

### 実装

- [ ] ドメイン層を分離
- [ ] リポジトリパターンを適用
- [ ] ドメインイベントを実装

## カリキュラム完了！

おめでとうございます！DDD のカリキュラムを完了しました。

### 学んだこと

1. **戦略的設計** - 境界づけられたコンテキスト、コンテキストマップ
2. **戦術的設計** - エンティティ、値オブジェクト、集約
3. **ユビキタス言語** - 共通言語の重要性
4. **リポジトリ** - 永続化の抽象化
5. **ドメインサービス** - クロスカッティングなロジック

### アーキテクト・テックリードとして

- マイクロサービスの境界を DDD で定義
- チームとドメインエキスパートの橋渡し
- 複雑なビジネスロジックの整理
