# Phase 3-1: 総仕上げ ～ NoSQL 実践プロジェクト ～

## 学習目標

この単元を終えると、以下ができるようになります：

- 実践的な NoSQL 設計ができる
- コスト最適化を考慮した設計ができる
- 運用を意識した実装ができる

## 総合演習: SNS アプリのデータ設計

### 要件

```
機能要件:
- ユーザープロフィール
- 投稿（テキスト、画像）
- フォロー/フォロワー
- タイムライン
- いいね、コメント

非機能要件:
- 高スループット（10万投稿/分）
- 低レイテンシ（<100ms）
- スケーラブル
```

### アクセスパターン分析

```python
# access_patterns.py
"""
SNSアプリのアクセスパターン
"""

ACCESS_PATTERNS = [
    # ユーザー
    {'name': 'ユーザープロフィール取得', 'frequency': 'high'},
    {'name': 'ユーザーの投稿一覧', 'frequency': 'high'},
    {'name': 'フォロー一覧', 'frequency': 'medium'},
    {'name': 'フォロワー一覧', 'frequency': 'medium'},
    
    # 投稿
    {'name': '投稿詳細', 'frequency': 'high'},
    {'name': '投稿のコメント', 'frequency': 'medium'},
    {'name': '投稿のいいね数', 'frequency': 'high'},
    {'name': 'いいねしたか確認', 'frequency': 'high'},
    
    # タイムライン
    {'name': 'ホームタイムライン', 'frequency': 'very_high'},
    {'name': 'トレンド投稿', 'frequency': 'high'},
]
```

### テーブル設計

```python
# table_design.py
"""
シングルテーブル設計
"""

TABLE_SCHEMA = {
    'TableName': 'SNSApp',
    'KeySchema': [
        {'AttributeName': 'PK', 'KeyType': 'HASH'},
        {'AttributeName': 'SK', 'KeyType': 'RANGE'}
    ],
    'GlobalSecondaryIndexes': [
        {
            'IndexName': 'GSI1',
            'KeySchema': [
                {'AttributeName': 'GSI1PK', 'KeyType': 'HASH'},
                {'AttributeName': 'GSI1SK', 'KeyType': 'RANGE'}
            ]
        },
        {
            'IndexName': 'GSI2',
            'KeySchema': [
                {'AttributeName': 'GSI2PK', 'KeyType': 'HASH'},
                {'AttributeName': 'GSI2SK', 'KeyType': 'RANGE'}
            ]
        }
    ],
    'BillingMode': 'PAY_PER_REQUEST'
}

# エンティティ設計
ENTITIES = {
    'User': {
        'PK': 'USER#{userId}',
        'SK': 'PROFILE',
        'GSI1PK': 'USER',
        'GSI1SK': 'USER#{userId}'
    },
    'Post': {
        'PK': 'USER#{userId}',
        'SK': 'POST#{timestamp}#{postId}',
        'GSI1PK': 'POST#{postId}',
        'GSI1SK': 'POST#{postId}'
    },
    'Follow': {
        'PK': 'USER#{userId}',
        'SK': 'FOLLOWS#{targetUserId}',
        'GSI1PK': 'USER#{targetUserId}',
        'GSI1SK': 'FOLLOWER#{userId}'
    },
    'Like': {
        'PK': 'POST#{postId}',
        'SK': 'LIKE#{userId}',
        'GSI1PK': 'USER#{userId}',
        'GSI1SK': 'LIKED#{postId}'
    },
    'Comment': {
        'PK': 'POST#{postId}',
        'SK': 'COMMENT#{timestamp}#{commentId}',
        'GSI1PK': 'USER#{userId}',
        'GSI1SK': 'COMMENTED#{postId}'
    },
    'Timeline': {
        'PK': 'TIMELINE#{userId}',
        'SK': '{timestamp}#{postId}',
        # ファンアウト方式
    }
}
```

### 実装

```python
# sns_repository.py
"""
SNSアプリのリポジトリ
"""

import boto3
from boto3.dynamodb.conditions import Key
from datetime import datetime
import uuid

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table('SNSApp')

class UserRepository:
    @staticmethod
    def create_user(user_id: str, name: str, bio: str = ''):
        table.put_item(Item={
            'PK': f'USER#{user_id}',
            'SK': 'PROFILE',
            'userId': user_id,
            'name': name,
            'bio': bio,
            'followerCount': 0,
            'followingCount': 0,
            'postCount': 0,
            'GSI1PK': 'USER',
            'GSI1SK': f'USER#{user_id}',
            'createdAt': datetime.utcnow().isoformat()
        })
    
    @staticmethod
    def get_user(user_id: str):
        response = table.get_item(
            Key={'PK': f'USER#{user_id}', 'SK': 'PROFILE'}
        )
        return response.get('Item')
    
    @staticmethod
    def get_user_posts(user_id: str, limit: int = 20):
        response = table.query(
            KeyConditionExpression=
                Key('PK').eq(f'USER#{user_id}') &
                Key('SK').begins_with('POST#'),
            Limit=limit,
            ScanIndexForward=False
        )
        return response['Items']

class PostRepository:
    @staticmethod
    def create_post(user_id: str, content: str, image_url: str = None):
        post_id = str(uuid.uuid4())[:8]
        timestamp = datetime.utcnow().isoformat()
        
        # 投稿作成
        table.put_item(Item={
            'PK': f'USER#{user_id}',
            'SK': f'POST#{timestamp}#{post_id}',
            'postId': post_id,
            'userId': user_id,
            'content': content,
            'imageUrl': image_url,
            'likeCount': 0,
            'commentCount': 0,
            'GSI1PK': f'POST#{post_id}',
            'GSI1SK': f'POST#{post_id}',
            'createdAt': timestamp
        })
        
        # ユーザーの投稿数更新
        table.update_item(
            Key={'PK': f'USER#{user_id}', 'SK': 'PROFILE'},
            UpdateExpression='ADD postCount :inc',
            ExpressionAttributeValues={':inc': 1}
        )
        
        return post_id
    
    @staticmethod
    def get_post(post_id: str):
        response = table.query(
            IndexName='GSI1',
            KeyConditionExpression=Key('GSI1PK').eq(f'POST#{post_id}')
        )
        return response['Items'][0] if response['Items'] else None

class FollowRepository:
    @staticmethod
    def follow(follower_id: str, following_id: str):
        # トランザクションで3つの操作
        dynamodb.meta.client.transact_write_items(
            TransactItems=[
                # フォロー関係作成
                {
                    'Put': {
                        'TableName': 'SNSApp',
                        'Item': {
                            'PK': {'S': f'USER#{follower_id}'},
                            'SK': {'S': f'FOLLOWS#{following_id}'},
                            'GSI1PK': {'S': f'USER#{following_id}'},
                            'GSI1SK': {'S': f'FOLLOWER#{follower_id}'},
                            'createdAt': {'S': datetime.utcnow().isoformat()}
                        },
                        'ConditionExpression': 'attribute_not_exists(PK)'
                    }
                },
                # フォロワー数増加
                {
                    'Update': {
                        'TableName': 'SNSApp',
                        'Key': {
                            'PK': {'S': f'USER#{following_id}'},
                            'SK': {'S': 'PROFILE'}
                        },
                        'UpdateExpression': 'ADD followerCount :inc',
                        'ExpressionAttributeValues': {':inc': {'N': '1'}}
                    }
                },
                # フォロー数増加
                {
                    'Update': {
                        'TableName': 'SNSApp',
                        'Key': {
                            'PK': {'S': f'USER#{follower_id}'},
                            'SK': {'S': 'PROFILE'}
                        },
                        'UpdateExpression': 'ADD followingCount :inc',
                        'ExpressionAttributeValues': {':inc': {'N': '1'}}
                    }
                }
            ]
        )
    
    @staticmethod
    def get_following(user_id: str, limit: int = 20):
        response = table.query(
            KeyConditionExpression=
                Key('PK').eq(f'USER#{user_id}') &
                Key('SK').begins_with('FOLLOWS#'),
            Limit=limit
        )
        return response['Items']
    
    @staticmethod
    def get_followers(user_id: str, limit: int = 20):
        response = table.query(
            IndexName='GSI1',
            KeyConditionExpression=
                Key('GSI1PK').eq(f'USER#{user_id}') &
                Key('GSI1SK').begins_with('FOLLOWER#'),
            Limit=limit
        )
        return response['Items']

class LikeRepository:
    @staticmethod
    def like_post(user_id: str, post_id: str):
        # いいね追加とカウント更新
        dynamodb.meta.client.transact_write_items(
            TransactItems=[
                {
                    'Put': {
                        'TableName': 'SNSApp',
                        'Item': {
                            'PK': {'S': f'POST#{post_id}'},
                            'SK': {'S': f'LIKE#{user_id}'},
                            'GSI1PK': {'S': f'USER#{user_id}'},
                            'GSI1SK': {'S': f'LIKED#{post_id}'},
                            'createdAt': {'S': datetime.utcnow().isoformat()}
                        },
                        'ConditionExpression': 'attribute_not_exists(PK)'
                    }
                },
                {
                    'Update': {
                        'TableName': 'SNSApp',
                        'Key': {
                            'PK': {'S': f'POST#{post_id}'},
                            'SK': {'S': f'POST#{post_id}'}
                        },
                        'UpdateExpression': 'ADD likeCount :inc',
                        'ExpressionAttributeValues': {':inc': {'N': '1'}}
                    }
                }
            ]
        )
    
    @staticmethod
    def has_liked(user_id: str, post_id: str) -> bool:
        response = table.get_item(
            Key={'PK': f'POST#{post_id}', 'SK': f'LIKE#{user_id}'}
        )
        return 'Item' in response
```

## コスト最適化

| 最適化 | 手法 |
|-------|------|
| **On-Demand** | 予測困難な場合 |
| **予約容量** | 安定ワークロード（最大75%割引） |
| **TTL** | 古いデータを自動削除 |
| **GSI削減** | 必要最小限に |

## 監視

```python
# monitoring.py
"""
DynamoDB監視
"""

import boto3

cloudwatch = boto3.client('cloudwatch')

def create_alarms():
    # スロットリングアラーム
    cloudwatch.put_metric_alarm(
        AlarmName='DynamoDB-Throttling',
        MetricName='ThrottledRequests',
        Namespace='AWS/DynamoDB',
        Dimensions=[
            {'Name': 'TableName', 'Value': 'SNSApp'}
        ],
        Statistic='Sum',
        Period=60,
        EvaluationPeriods=1,
        Threshold=1,
        ComparisonOperator='GreaterThanThreshold',
        AlarmActions=['arn:aws:sns:...:alerts']
    )
    
    # 高消費容量アラーム
    cloudwatch.put_metric_alarm(
        AlarmName='DynamoDB-HighConsumedCapacity',
        MetricName='ConsumedReadCapacityUnits',
        Namespace='AWS/DynamoDB',
        Dimensions=[
            {'Name': 'TableName', 'Value': 'SNSApp'}
        ],
        Statistic='Average',
        Period=300,
        EvaluationPeriods=3,
        Threshold=80,  # 80%
        ComparisonOperator='GreaterThanThreshold'
    )
```

## カリキュラム完了！

おめでとうございます！NoSQL 深掘りのカリキュラムを完了しました。

### 学んだこと

1. **NoSQL の種類** - Key-Value, Document, Column, Graph
2. **DynamoDB 基礎** - PK/SK, GSI/LSI, CRUD
3. **シングルテーブル設計** - エンティティ統合、オーバーロード
4. **アクセスパターン** - 階層構造、時系列、多対多
5. **実践設計** - SNSアプリのデータモデル

### AWS 経験を活かして

DynamoDB は Lambda との相性が抜群です。あなたの Lambda 経験と組み合わせて、スケーラブルなサーバーレスアプリケーションを構築できます。
