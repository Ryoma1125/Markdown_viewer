# Phase 5-2: データフェッチ

## 学習目標

この単元を終えると、以下ができるようになります：

- TanStack Query でデータ取得できる
- キャッシュを活用できる
- 楽観的更新を実装できる

## TanStack Query（React Query）

```bash
npm install @tanstack/react-query
```

## セットアップ

```tsx
// src/main.tsx
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';

const queryClient = new QueryClient();

ReactDOM.createRoot(document.getElementById('root')!).render(
    <QueryClientProvider client={queryClient}>
        <App />
    </QueryClientProvider>
);
```

## 基本的なデータ取得

```tsx
import { useQuery } from '@tanstack/react-query';

interface User {
    id: number;
    name: string;
    email: string;
}

async function fetchUsers(): Promise<User[]> {
    const response = await fetch('/api/users');
    if (!response.ok) throw new Error('Failed to fetch');
    return response.json();
}

function UserList() {
    const { data, isLoading, error } = useQuery({
        queryKey: ['users'],
        queryFn: fetchUsers,
    });
    
    if (isLoading) return <p>Loading...</p>;
    if (error) return <p>Error: {error.message}</p>;
    
    return (
        <ul>
            {data?.map(user => (
                <li key={user.id}>{user.name}</li>
            ))}
        </ul>
    );
}
```

## ハンズオン

### 演習1: 投稿一覧

```tsx
// src/api/posts.ts
const API_BASE = 'https://jsonplaceholder.typicode.com';

export interface Post {
    id: number;
    title: string;
    body: string;
    userId: number;
}

export async function fetchPosts(): Promise<Post[]> {
    const response = await fetch(`${API_BASE}/posts`);
    if (!response.ok) throw new Error('Failed to fetch posts');
    return response.json();
}

export async function fetchPost(id: number): Promise<Post> {
    const response = await fetch(`${API_BASE}/posts/${id}`);
    if (!response.ok) throw new Error('Failed to fetch post');
    return response.json();
}
```

```tsx
// src/components/PostList.tsx
import { useQuery } from '@tanstack/react-query';
import { Link } from 'react-router-dom';
import { fetchPosts, Post } from '../api/posts';

function PostList() {
    const { data: posts, isLoading, error } = useQuery({
        queryKey: ['posts'],
        queryFn: fetchPosts,
        staleTime: 5 * 60 * 1000,  // 5分間キャッシュ
    });
    
    if (isLoading) {
        return (
            <div style={{ padding: '20px' }}>
                <div>Loading...</div>
            </div>
        );
    }
    
    if (error) {
        return (
            <div style={{ padding: '20px', color: 'red' }}>
                Error: {error.message}
            </div>
        );
    }
    
    return (
        <div style={{ padding: '20px' }}>
            <h2>投稿一覧</h2>
            <div style={{ display: 'grid', gap: '16px' }}>
                {posts?.slice(0, 10).map(post => (
                    <Link
                        key={post.id}
                        to={`/posts/${post.id}`}
                        style={{
                            display: 'block',
                            padding: '16px',
                            border: '1px solid #ddd',
                            borderRadius: '8px',
                            textDecoration: 'none',
                            color: 'inherit'
                        }}
                    >
                        <h3 style={{ margin: 0 }}>{post.title}</h3>
                        <p style={{ color: '#666' }}>
                            {post.body.substring(0, 100)}...
                        </p>
                    </Link>
                ))}
            </div>
        </div>
    );
}

export default PostList;
```

### 演習2: 詳細ページ

```tsx
// src/components/PostDetail.tsx
import { useQuery } from '@tanstack/react-query';
import { useParams, Link } from 'react-router-dom';
import { fetchPost } from '../api/posts';

function PostDetail() {
    const { id } = useParams<{ id: string }>();
    
    const { data: post, isLoading, error } = useQuery({
        queryKey: ['post', id],
        queryFn: () => fetchPost(Number(id)),
        enabled: !!id,  // id がある時のみ実行
    });
    
    if (isLoading) return <p>Loading...</p>;
    if (error) return <p>Error: {error.message}</p>;
    if (!post) return <p>Post not found</p>;
    
    return (
        <div style={{ padding: '20px' }}>
            <Link to="/posts">← 一覧に戻る</Link>
            <h1>{post.title}</h1>
            <p>{post.body}</p>
        </div>
    );
}

export default PostDetail;
```

### 演習3: Mutation（データ更新）

```tsx
// src/api/posts.ts に追加
export async function createPost(post: Omit<Post, 'id'>): Promise<Post> {
    const response = await fetch(`${API_BASE}/posts`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(post),
    });
    if (!response.ok) throw new Error('Failed to create post');
    return response.json();
}
```

```tsx
// src/components/CreatePost.tsx
import { useMutation, useQueryClient } from '@tanstack/react-query';
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';
import { createPost } from '../api/posts';

function CreatePost() {
    const [title, setTitle] = useState('');
    const [body, setBody] = useState('');
    const navigate = useNavigate();
    const queryClient = useQueryClient();
    
    const mutation = useMutation({
        mutationFn: createPost,
        onSuccess: () => {
            // キャッシュを無効化して再取得
            queryClient.invalidateQueries({ queryKey: ['posts'] });
            navigate('/posts');
        },
    });
    
    const handleSubmit = (e: React.FormEvent) => {
        e.preventDefault();
        mutation.mutate({ title, body, userId: 1 });
    };
    
    return (
        <form onSubmit={handleSubmit} style={{ padding: '20px', maxWidth: '600px' }}>
            <h2>新規投稿</h2>
            
            <div style={{ marginBottom: '16px' }}>
                <label>タイトル</label>
                <input
                    type="text"
                    value={title}
                    onChange={(e) => setTitle(e.target.value)}
                    style={{ width: '100%', padding: '8px' }}
                    required
                />
            </div>
            
            <div style={{ marginBottom: '16px' }}>
                <label>本文</label>
                <textarea
                    value={body}
                    onChange={(e) => setBody(e.target.value)}
                    rows={5}
                    style={{ width: '100%', padding: '8px' }}
                    required
                />
            </div>
            
            <button
                type="submit"
                disabled={mutation.isPending}
                style={{
                    padding: '10px 20px',
                    backgroundColor: mutation.isPending ? '#ccc' : '#007bff',
                    color: 'white',
                    border: 'none',
                    borderRadius: '4px'
                }}
            >
                {mutation.isPending ? '送信中...' : '投稿'}
            </button>
            
            {mutation.error && (
                <p style={{ color: 'red' }}>{mutation.error.message}</p>
            )}
        </form>
    );
}

export default CreatePost;
```

### 演習4: 楽観的更新

```tsx
// いいねボタンの楽観的更新
import { useMutation, useQueryClient } from '@tanstack/react-query';

function LikeButton({ postId, initialLikes }: { postId: number; initialLikes: number }) {
    const queryClient = useQueryClient();
    
    const mutation = useMutation({
        mutationFn: async () => {
            const response = await fetch(`/api/posts/${postId}/like`, {
                method: 'POST'
            });
            return response.json();
        },
        onMutate: async () => {
            // 進行中のクエリをキャンセル
            await queryClient.cancelQueries({ queryKey: ['post', postId] });
            
            // 前の値を保存
            const previousPost = queryClient.getQueryData(['post', postId]);
            
            // 楽観的に更新
            queryClient.setQueryData(['post', postId], (old: any) => ({
                ...old,
                likes: old.likes + 1
            }));
            
            return { previousPost };
        },
        onError: (err, variables, context) => {
            // エラー時にロールバック
            if (context?.previousPost) {
                queryClient.setQueryData(['post', postId], context.previousPost);
            }
        },
        onSettled: () => {
            // 最終的にサーバーと同期
            queryClient.invalidateQueries({ queryKey: ['post', postId] });
        },
    });
    
    return (
        <button onClick={() => mutation.mutate()}>
            ❤️ {initialLikes}
        </button>
    );
}
```

## TanStack Query の利点

| 機能 | 説明 |
|------|------|
| キャッシュ | 自動キャッシュ管理 |
| 再取得 | 自動再取得、手動再取得 |
| 楽観的更新 | UX 向上 |
| DevTools | 状態の可視化 |
| 型安全 | TypeScript サポート |

## 理解度確認

### 問題

TanStack Query でキャッシュを無効化するメソッドはどれか。

**A.** `queryClient.clearQueries()`

**B.** `queryClient.invalidateQueries()`

**C.** `queryClient.removeQueries()`

**D.** `queryClient.resetQueries()`

---

### 解答・解説

**正解: B**

```tsx
queryClient.invalidateQueries({ queryKey: ['posts'] });
```

`invalidateQueries` はキャッシュを「古い」とマークし、次のアクセス時に再取得します。

---

## 次のステップ

データフェッチを学びました。次は総仕上げです。

**次の単元**: [Phase 6-1: 総仕上げ](../phase6/01_総仕上げ.md)
