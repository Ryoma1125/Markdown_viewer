# Phase 4-1: ç·ä»•ä¸Šã’ ï½ å®Œå…¨ãª CI/CD æ§‹ç¯‰ ï½

## å­¦ç¿’ç›®æ¨™

ã“ã®å˜å…ƒã‚’çµ‚ãˆã‚‹ã¨ã€ä»¥ä¸‹ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã¾ã™ï¼š

- æœ¬ç•ªãƒ¬ãƒ™ãƒ«ã® CI/CD ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã‚’æ§‹ç¯‰ã§ãã‚‹
- ç›£è¦–ãƒ»é€šçŸ¥ãƒ»ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯ã‚’çµ±åˆã§ãã‚‹
- ãƒãƒ¼ãƒ ã§ã®é‹ç”¨ã‚’è¨­è¨ˆã§ãã‚‹

## ç·åˆæ¼”ç¿’: æœ¬ç•ªå¯¾å¿œ CI/CD

### ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆæ§‹æˆ

```
my-app/
â”œâ”€â”€ .github/
â”‚   â”œâ”€â”€ workflows/
â”‚   â”‚   â”œâ”€â”€ ci.yml          # ãƒ†ã‚¹ãƒˆãƒ»ãƒ“ãƒ«ãƒ‰
â”‚   â”‚   â”œâ”€â”€ cd-staging.yml   # ã‚¹ãƒ†ãƒ¼ã‚¸ãƒ³ã‚°ãƒ‡ãƒ—ãƒ­ã‚¤
â”‚   â”‚   â”œâ”€â”€ cd-production.yml # æœ¬ç•ªãƒ‡ãƒ—ãƒ­ã‚¤
â”‚   â”‚   â”œâ”€â”€ security.yml     # ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³
â”‚   â”‚   â””â”€â”€ release.yml      # ãƒªãƒªãƒ¼ã‚¹ä½œæˆ
â”‚   â”œâ”€â”€ dependabot.yml
â”‚   â””â”€â”€ CODEOWNERS
â”œâ”€â”€ k8s/
â”‚   â”œâ”€â”€ base/
â”‚   â””â”€â”€ overlays/
â”œâ”€â”€ src/
â”œâ”€â”€ tests/
â””â”€â”€ Dockerfile
```

### æ¼”ç¿’1: CI ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼

```yaml
# .github/workflows/ci.yml
name: CI

on:
  push:
    branches: [main, develop, 'feature/**']
  pull_request:
    branches: [main, develop]

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # å¤‰æ›´ãƒ•ã‚¡ã‚¤ãƒ«ã®æ¤œå‡º
  changes:
    runs-on: ubuntu-latest
    outputs:
      src: ${{ steps.changes.outputs.src }}
      tests: ${{ steps.changes.outputs.tests }}
      docker: ${{ steps.changes.outputs.docker }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v2
        id: changes
        with:
          filters: |
            src:
              - 'src/**'
            tests:
              - 'tests/**'
            docker:
              - 'Dockerfile'
              - 'requirements*.txt'
  
  # Lint
  lint:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Install linters
        run: pip install flake8 black isort mypy
      
      - name: Flake8
        run: flake8 src/ tests/
      
      - name: Black
        run: black --check src/ tests/
      
      - name: isort
        run: isort --check-only src/ tests/
      
      - name: MyPy
        run: mypy src/
  
  # Test
  test:
    needs: [lint, changes]
    if: needs.changes.outputs.src == 'true' || needs.changes.outputs.tests == 'true'
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test
          POSTGRES_DB: testdb
        ports: ['5432:5432']
        options: --health-cmd pg_isready --health-interval 10s --health-timeout 5s --health-retries 5
      
      redis:
        image: redis:7
        ports: ['6379:6379']
    
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.11'
      
      - name: Cache pip
        uses: actions/cache@v4
        with:
          path: ~/.cache/pip
          key: ${{ runner.os }}-pip-${{ hashFiles('requirements*.txt') }}
      
      - name: Install dependencies
        run: pip install -r requirements-dev.txt
      
      - name: Run tests
        env:
          DATABASE_URL: postgresql://postgres:test@localhost:5432/testdb
          REDIS_URL: redis://localhost:6379
        run: |
          pytest tests/ \
            -v \
            --cov=src \
            --cov-report=xml \
            --cov-report=html \
            --cov-fail-under=80 \
            --junitxml=junit.xml
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.xml
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: |
            junit.xml
            htmlcov/
  
  # Build
  build:
    needs: [test, changes]
    if: github.event_name == 'push' && (needs.changes.outputs.src == 'true' || needs.changes.outputs.docker == 'true')
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    outputs:
      image: ${{ steps.image.outputs.name }}
      digest: ${{ steps.build.outputs.digest }}
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
      
      - name: Login to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha
            type=ref,event=branch
      
      - name: Build and push
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          provenance: true
          sbom: true
      
      - name: Output image name
        id: image
        run: echo "name=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}@${{ steps.build.outputs.digest }}" >> $GITHUB_OUTPUT
  
  # Security Scan
  security:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      
      - name: Run Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ needs.build.outputs.image }}
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'
      
      - name: Upload Trivy scan results
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'
```

### æ¼”ç¿’2: CD ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ï¼ˆStagingï¼‰

```yaml
# .github/workflows/cd-staging.yml
name: Deploy to Staging

on:
  workflow_run:
    workflows: [CI]
    types: [completed]
    branches: [main]

jobs:
  deploy:
    if: github.event.workflow_run.conclusion == 'success'
    runs-on: ubuntu-latest
    environment: staging
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Get image from CI
        id: image
        run: |
          # CI ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã‹ã‚‰ã‚¤ãƒ¡ãƒ¼ã‚¸æƒ…å ±ã‚’å–å¾—
          IMAGE="ghcr.io/${{ github.repository }}:sha-$(echo ${{ github.event.workflow_run.head_sha }} | cut -c1-7)"
          echo "name=$IMAGE" >> $GITHUB_OUTPUT
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Configure kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG_STAGING }}" | base64 -d > ~/.kube/config
      
      - name: Deploy
        run: |
          # Kustomize ã§ã‚¤ãƒ¡ãƒ¼ã‚¸ã‚’æ›´æ–°
          cd k8s/overlays/staging
          kustomize edit set image myapp=${{ steps.image.outputs.name }}
          kustomize build . | kubectl apply -f -
          kubectl rollout status deployment/myapp -n staging --timeout=300s
      
      - name: Smoke test
        run: |
          STAGING_URL=$(kubectl get ingress myapp -n staging -o jsonpath='{.spec.rules[0].host}')
          for i in {1..10}; do
            if curl -sf "https://$STAGING_URL/health"; then
              echo "Health check passed"
              exit 0
            fi
            sleep 5
          done
          echo "Health check failed"
          exit 1
      
      - name: Notify Slack
        if: always()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "${{ job.status == 'success' && 'âœ…' || 'âŒ' }} Staging deploy ${{ job.status }}",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Staging Deploy*\nStatus: ${{ job.status }}\nImage: `${{ steps.image.outputs.name }}`"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
```

### æ¼”ç¿’3: CD ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ï¼ˆProductionï¼‰

```yaml
# .github/workflows/cd-production.yml
name: Deploy to Production

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      image:
        description: 'Image to deploy'
        required: true

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Determine image
        id: image
        run: |
          if [ "${{ github.event_name }}" == "release" ]; then
            IMAGE="ghcr.io/${{ github.repository }}:${{ github.event.release.tag_name }}"
          else
            IMAGE="${{ github.event.inputs.image }}"
          fi
          echo "name=$IMAGE" >> $GITHUB_OUTPUT
      
      - name: Configure kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG_PRODUCTION }}" | base64 -d > ~/.kube/config
      
      - name: Backup current version
        run: |
          kubectl get deployment myapp -n production -o yaml > /tmp/backup.yaml
          echo "backup_file=/tmp/backup.yaml" >> $GITHUB_ENV
      
      - name: Deploy
        id: deploy
        run: |
          cd k8s/overlays/production
          kustomize edit set image myapp=${{ steps.image.outputs.name }}
          kustomize build . | kubectl apply -f -
          kubectl rollout status deployment/myapp -n production --timeout=600s
      
      - name: Health check
        id: health
        run: |
          PROD_URL=$(kubectl get ingress myapp -n production -o jsonpath='{.spec.rules[0].host}')
          for i in {1..20}; do
            if curl -sf "https://$PROD_URL/health"; then
              echo "Health check passed"
              exit 0
            fi
            sleep 10
          done
          echo "Health check failed"
          exit 1
      
      - name: Rollback on failure
        if: failure() && steps.deploy.outcome == 'success'
        run: |
          echo "Rolling back..."
          kubectl rollout undo deployment/myapp -n production
          kubectl rollout status deployment/myapp -n production
      
      - name: Create deployment record
        if: success()
        run: |
          echo "Recording deployment..."
          # Datadog, New Relic ãªã©ã¸ã®ãƒ‡ãƒ—ãƒ­ã‚¤è¨˜éŒ²
      
      - name: Notify
        if: always()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "${{ job.status == 'success' && 'ğŸš€' || 'ğŸ”¥' }} Production deploy ${{ job.status }}"
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
```

## CI/CD é‹ç”¨ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

```markdown
## ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³è¨­è¨ˆ
- [ ] ãƒ†ã‚¹ãƒˆã¯ä¸¦åˆ—å®Ÿè¡Œ
- [ ] ã‚­ãƒ£ãƒƒã‚·ãƒ¥ã‚’æ´»ç”¨
- [ ] ä¸è¦ãªã‚¸ãƒ§ãƒ–ã¯ã‚¹ã‚­ãƒƒãƒ—
- [ ] åŒæ™‚å®Ÿè¡Œã®åˆ¶å¾¡ï¼ˆconcurrencyï¼‰

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£
- [ ] Secrets ã¯ GitHub Secrets ã«ä¿å­˜
- [ ] ä¾å­˜é–¢ä¿‚ã®è„†å¼±æ€§ã‚¹ã‚­ãƒ£ãƒ³
- [ ] ã‚³ãƒ³ãƒ†ãƒŠã‚¤ãƒ¡ãƒ¼ã‚¸ã®ã‚¹ã‚­ãƒ£ãƒ³
- [ ] SBOMï¼ˆã‚½ãƒ•ãƒˆã‚¦ã‚§ã‚¢éƒ¨å“è¡¨ï¼‰ç”Ÿæˆ

## ãƒ‡ãƒ—ãƒ­ã‚¤
- [ ] Staging ã§æ¤œè¨¼å¾Œã« Production
- [ ] ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯å¿…é ˆ
- [ ] ãƒ­ãƒ¼ãƒ«ãƒãƒƒã‚¯æ‰‹é †ã‚ã‚Š
- [ ] ãƒ‡ãƒ—ãƒ­ã‚¤è¨˜éŒ²ã‚’æ®‹ã™

## ç›£è¦–ãƒ»é€šçŸ¥
- [ ] Slack/Teams ã¸ã®é€šçŸ¥
- [ ] å¤±æ•—æ™‚ã®ã‚¢ãƒ©ãƒ¼ãƒˆ
- [ ] ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†
```

## ã‚«ãƒªã‚­ãƒ¥ãƒ©ãƒ å®Œäº†ï¼

ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼CI/CD ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³ã®ã‚«ãƒªã‚­ãƒ¥ãƒ©ãƒ ã‚’å®Œäº†ã—ã¾ã—ãŸã€‚

### å­¦ã‚“ã ã“ã¨

1. **CI/CD ã®æ¦‚å¿µ** - ç¶™ç¶šçš„ã‚¤ãƒ³ãƒ†ã‚°ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³/ãƒ‡ãƒªãƒãƒªãƒ¼
2. **GitHub Actions** - ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼ã€ã‚¸ãƒ§ãƒ–ã€ã‚¹ãƒ†ãƒƒãƒ—
3. **ãƒ†ã‚¹ãƒˆè‡ªå‹•åŒ–** - pytest, Lint, ã‚«ãƒãƒ¬ãƒƒã‚¸
4. **ãƒ“ãƒ«ãƒ‰è‡ªå‹•åŒ–** - Docker, ãƒ¬ã‚¸ã‚¹ãƒˆãƒª
5. **ãƒ‡ãƒ—ãƒ­ã‚¤è‡ªå‹•åŒ–** - ç’°å¢ƒç®¡ç†ã€æˆ¦ç•¥
6. **å®Ÿè·µãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³** - æœ¬ç•ªå¯¾å¿œã®è¨­è¨ˆ

### æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—

- **ArgoCD** - GitOps ã«ã‚ˆã‚‹ãƒ‡ãƒ—ãƒ­ã‚¤
- **Terraform** - ã‚¤ãƒ³ãƒ•ãƒ©ã® CI/CD
- **ç›£è¦–** - Datadog, New Relic é€£æº
- **Feature Flags** - æ®µéšçš„ãƒªãƒªãƒ¼ã‚¹
