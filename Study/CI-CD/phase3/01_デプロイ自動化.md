# Phase 3-1: デプロイ自動化

## 学習目標

この単元を終えると、以下ができるようになります：

- 環境ごとのデプロイを設定できる
- GitHub Environments を活用できる
- 安全なデプロイ戦略を実装できる

## ハンズオン

### 演習1: GitHub Environments

```yaml
# .github/workflows/deploy.yml
name: Deploy

on:
  push:
    branches: [main]

jobs:
  deploy-staging:
    runs-on: ubuntu-latest
    environment: staging  # 環境を指定
    
    steps:
      - name: Deploy to Staging
        run: echo "Deploying to staging..."
  
  deploy-production:
    needs: deploy-staging
    runs-on: ubuntu-latest
    environment: production  # 承認が必要な環境
    
    steps:
      - name: Deploy to Production
        run: echo "Deploying to production..."
```

**GitHub Environments 設定**
1. リポジトリ Settings → Environments
2. New environment で `staging`, `production` を作成
3. production に Required reviewers を設定

### 演習2: AWS ECS へのデプロイ

```yaml
# .github/workflows/deploy-ecs.yml
name: Deploy to ECS

on:
  push:
    branches: [main]

env:
  AWS_REGION: ap-northeast-1
  ECR_REPOSITORY: myapp
  ECS_SERVICE: myapp-service
  ECS_CLUSTER: myapp-cluster
  CONTAINER_NAME: myapp

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      
      - name: Build and push image
        id: build
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image=$ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG" >> $GITHUB_OUTPUT
      
      - name: Download task definition
        run: |
          aws ecs describe-task-definition \
            --task-definition myapp-task \
            --query taskDefinition > task-definition.json
      
      - name: Update task definition
        id: task-def
        uses: aws-actions/amazon-ecs-render-task-definition@v1
        with:
          task-definition: task-definition.json
          container-name: ${{ env.CONTAINER_NAME }}
          image: ${{ steps.build.outputs.image }}
      
      - name: Deploy to ECS
        uses: aws-actions/amazon-ecs-deploy-task-definition@v1
        with:
          task-definition: ${{ steps.task-def.outputs.task-definition }}
          service: ${{ env.ECS_SERVICE }}
          cluster: ${{ env.ECS_CLUSTER }}
          wait-for-service-stability: true
```

### 演習3: Kubernetes (kubectl) デプロイ

```yaml
# .github/workflows/deploy-k8s.yml
name: Deploy to Kubernetes

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Set up kubectl
        uses: azure/setup-kubectl@v3
      
      - name: Configure kubeconfig
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > ~/.kube/config
      
      - name: Update image tag
        run: |
          sed -i "s|IMAGE_TAG|${{ github.sha }}|g" k8s/deployment.yaml
      
      - name: Deploy
        run: |
          kubectl apply -f k8s/
          kubectl rollout status deployment/myapp -n production
```

### 演習4: ブルーグリーンデプロイ

```yaml
# .github/workflows/blue-green.yml
name: Blue-Green Deploy

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Configure kubectl
        run: |
          mkdir -p ~/.kube
          echo "${{ secrets.KUBECONFIG }}" | base64 -d > ~/.kube/config
      
      - name: Get current color
        id: color
        run: |
          current=$(kubectl get service myapp -o jsonpath='{.spec.selector.color}')
          if [ "$current" == "blue" ]; then
            echo "new=green" >> $GITHUB_OUTPUT
            echo "old=blue" >> $GITHUB_OUTPUT
          else
            echo "new=blue" >> $GITHUB_OUTPUT
            echo "old=green" >> $GITHUB_OUTPUT
          fi
      
      - name: Deploy new version
        run: |
          # 新しい色の Deployment を更新
          sed -i "s|COLOR|${{ steps.color.outputs.new }}|g" k8s/deployment-template.yaml
          sed -i "s|IMAGE_TAG|${{ github.sha }}|g" k8s/deployment-template.yaml
          kubectl apply -f k8s/deployment-template.yaml
          
          # 新しいバージョンが Ready になるまで待機
          kubectl rollout status deployment/myapp-${{ steps.color.outputs.new }}
      
      - name: Switch traffic
        run: |
          # Service を新しい色に切り替え
          kubectl patch service myapp -p '{"spec":{"selector":{"color":"${{ steps.color.outputs.new }}"}}}'
      
      - name: Verify
        run: |
          sleep 30
          # ヘルスチェック
          kubectl exec deploy/myapp-${{ steps.color.outputs.new }} -- curl -s localhost/health
      
      - name: Cleanup old version
        if: success()
        run: |
          kubectl scale deployment/myapp-${{ steps.color.outputs.old }} --replicas=0
```

### 演習5: カナリアデプロイ

```yaml
# .github/workflows/canary.yml
name: Canary Deploy

on:
  push:
    branches: [main]

jobs:
  canary:
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Deploy canary (10%)
        run: |
          # カナリアバージョンをデプロイ
          kubectl apply -f k8s/canary-deployment.yaml
          
          # トラフィックの10%をカナリアに
          kubectl apply -f k8s/canary-virtualservice.yaml
      
      - name: Monitor canary
        run: |
          # 5分間監視
          for i in {1..10}; do
            error_rate=$(curl -s http://prometheus/api/v1/query?query=error_rate | jq '.data.result[0].value[1]')
            if (( $(echo "$error_rate > 0.01" | bc -l) )); then
              echo "Error rate too high: $error_rate"
              exit 1
            fi
            sleep 30
          done
      
      - name: Promote canary
        if: success()
        run: |
          # 全トラフィックを新バージョンに
          kubectl apply -f k8s/full-rollout.yaml
      
      - name: Rollback on failure
        if: failure()
        run: |
          kubectl delete -f k8s/canary-deployment.yaml
          kubectl apply -f k8s/stable-virtualservice.yaml
```

### 演習6: デプロイ通知

```yaml
# .github/workflows/deploy-notify.yml
name: Deploy with Notification

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Deploy
        id: deploy
        run: |
          echo "Deploying..."
          echo "url=https://myapp.example.com" >> $GITHUB_OUTPUT
      
      - name: Notify Slack on success
        if: success()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "✅ Deploy succeeded!",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Deploy succeeded* :rocket:\n<${{ steps.deploy.outputs.url }}|View deployment>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
      
      - name: Notify Slack on failure
        if: failure()
        uses: slackapi/slack-github-action@v1
        with:
          payload: |
            {
              "text": "❌ Deploy failed!",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Deploy failed* :x:\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View logs>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
```

## デプロイ戦略比較

| 戦略 | ダウンタイム | ロールバック | リスク |
|-----|------------|------------|-------|
| ローリング | なし | 遅い | 中 |
| ブルーグリーン | なし | 即時 | 低 |
| カナリア | なし | 即時 | 最低 |
| 再作成 | あり | 遅い | 高 |

## 理解度確認

### 問題

本番デプロイ前に手動承認を必須にするための GitHub Actions の機能はどれか。

**A.** manual-approval アクション

**B.** GitHub Environments の Required reviewers

**C.** workflow_dispatch トリガー

**D.** if: github.event.inputs.approve == 'true'

---

### 解答・解説

**正解: B**

GitHub Environments で：
1. Settings → Environments → production
2. Required reviewers を設定
3. ワークフローで `environment: production` を指定

```yaml
jobs:
  deploy:
    environment: production  # 承認待ちになる
```

---

## 次のステップ

デプロイ自動化を学びました。次は実践的なパイプラインを構築しましょう。

**次の単元**: [Phase 3-2: 実践パイプライン](./02_実践パイプライン.md)
