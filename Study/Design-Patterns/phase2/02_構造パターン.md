# Phase 2-2: 構造パターン ～ オブジェクトの構成 ～

## 学習目標

この単元を終えると、以下ができるようになります：

- Adapter パターンでインターフェースを変換できる
- Decorator パターンで機能を動的に追加できる
- Facade パターンで複雑なシステムを簡単に使えるようにできる

## ハンズオン

### 演習1: Adapter パターン

**既存のクラスを別のインターフェースに適合させる**

```python
# 既存のサードパーティライブラリ（変更不可）
class OldPaymentGateway:
    def process_payment(self, amount_in_cents: int, card_number: str):
        print(f"Processing ${amount_in_cents / 100:.2f} with card {card_number[-4:]}")
        return {"success": True, "transaction_id": "TXN123"}

# 新しいインターフェース（我々のシステムで使いたい形）
from abc import ABC, abstractmethod

class PaymentProcessor(ABC):
    @abstractmethod
    def pay(self, amount: float, payment_method: dict) -> dict:
        pass

# Adapter
class OldPaymentAdapter(PaymentProcessor):
    def __init__(self, old_gateway: OldPaymentGateway):
        self.old_gateway = old_gateway
    
    def pay(self, amount: float, payment_method: dict) -> dict:
        # インターフェースを変換
        amount_in_cents = int(amount * 100)
        card_number = payment_method.get("card_number", "")
        
        result = self.old_gateway.process_payment(amount_in_cents, card_number)
        
        return {
            "status": "completed" if result["success"] else "failed",
            "reference": result["transaction_id"]
        }

# 使用
old_gateway = OldPaymentGateway()
adapter = OldPaymentAdapter(old_gateway)

result = adapter.pay(99.99, {"card_number": "4111111111111111"})
print(result)
```

```python
# 実践例：複数の決済サービスを統一インターフェースで使う
class StripeGateway:
    def charge(self, amount_cents: int, token: str):
        return {"id": "ch_xxx", "status": "succeeded"}

class PayPalGateway:
    def create_payment(self, amount_usd: float, email: str):
        return {"payment_id": "PAY-xxx", "state": "approved"}

class StripeAdapter(PaymentProcessor):
    def __init__(self, stripe: StripeGateway):
        self.stripe = stripe
    
    def pay(self, amount: float, payment_method: dict) -> dict:
        result = self.stripe.charge(int(amount * 100), payment_method["token"])
        return {"status": result["status"], "reference": result["id"]}

class PayPalAdapter(PaymentProcessor):
    def __init__(self, paypal: PayPalGateway):
        self.paypal = paypal
    
    def pay(self, amount: float, payment_method: dict) -> dict:
        result = self.paypal.create_payment(amount, payment_method["email"])
        return {"status": "completed" if result["state"] == "approved" else "failed",
                "reference": result["payment_id"]}

# 使用側は統一されたインターフェースで呼び出せる
def process_order(processor: PaymentProcessor, amount: float, method: dict):
    return processor.pay(amount, method)
```

### 演習2: Decorator パターン

**オブジェクトに動的に機能を追加する**

```python
from abc import ABC, abstractmethod

# 基本インターフェース
class Coffee(ABC):
    @abstractmethod
    def get_description(self) -> str:
        pass
    
    @abstractmethod
    def get_cost(self) -> float:
        pass

# 具体的なコーヒー
class Espresso(Coffee):
    def get_description(self) -> str:
        return "エスプレッソ"
    
    def get_cost(self) -> float:
        return 300

class Latte(Coffee):
    def get_description(self) -> str:
        return "ラテ"
    
    def get_cost(self) -> float:
        return 400

# Decorator 基底クラス
class CoffeeDecorator(Coffee):
    def __init__(self, coffee: Coffee):
        self._coffee = coffee
    
    def get_description(self) -> str:
        return self._coffee.get_description()
    
    def get_cost(self) -> float:
        return self._coffee.get_cost()

# 具体的な Decorator
class MilkDecorator(CoffeeDecorator):
    def get_description(self) -> str:
        return self._coffee.get_description() + " + ミルク"
    
    def get_cost(self) -> float:
        return self._coffee.get_cost() + 50

class SyrupDecorator(CoffeeDecorator):
    def __init__(self, coffee: Coffee, syrup_name: str):
        super().__init__(coffee)
        self.syrup_name = syrup_name
    
    def get_description(self) -> str:
        return self._coffee.get_description() + f" + {self.syrup_name}シロップ"
    
    def get_cost(self) -> float:
        return self._coffee.get_cost() + 30

class WhippedCreamDecorator(CoffeeDecorator):
    def get_description(self) -> str:
        return self._coffee.get_description() + " + ホイップ"
    
    def get_cost(self) -> float:
        return self._coffee.get_cost() + 80

# 使用例
espresso = Espresso()
print(f"{espresso.get_description()}: ¥{espresso.get_cost()}")

# デコレーターを重ねて適用
fancy_latte = WhippedCreamDecorator(
    SyrupDecorator(
        MilkDecorator(Latte()),
        "キャラメル"
    )
)
print(f"{fancy_latte.get_description()}: ¥{fancy_latte.get_cost()}")
```

```python
# 実践例：ログ機能を追加する Decorator
import time
from functools import wraps

def log_execution(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        print(f"[LOG] Calling {func.__name__}")
        start = time.time()
        result = func(*args, **kwargs)
        elapsed = time.time() - start
        print(f"[LOG] {func.__name__} completed in {elapsed:.3f}s")
        return result
    return wrapper

def retry(max_attempts: int = 3):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise
                    print(f"[RETRY] Attempt {attempt + 1} failed, retrying...")
        return wrapper
    return decorator

@log_execution
@retry(max_attempts=3)
def fetch_data(url: str):
    print(f"Fetching {url}")
    return {"data": "response"}

fetch_data("https://api.example.com")
```

### 演習3: Facade パターン

**複雑なサブシステムに対する簡単なインターフェースを提供**

```python
# 複雑なサブシステム
class Inventory:
    def check_stock(self, product_id: str) -> bool:
        print(f"Checking stock for {product_id}")
        return True
    
    def reserve(self, product_id: str, quantity: int):
        print(f"Reserving {quantity} of {product_id}")

class Payment:
    def validate_card(self, card_info: dict) -> bool:
        print("Validating card...")
        return True
    
    def charge(self, amount: float, card_info: dict) -> str:
        print(f"Charging ¥{amount}")
        return "TXN123"

class Shipping:
    def calculate_cost(self, address: str, weight: float) -> float:
        print("Calculating shipping cost...")
        return 500
    
    def schedule(self, address: str) -> str:
        print(f"Scheduling delivery to {address}")
        return "SHIP123"

class Notification:
    def send_confirmation(self, email: str, order_id: str):
        print(f"Sending confirmation to {email}")

# ❌ Facade なしだと使う側が複雑
def place_order_without_facade(product_id, quantity, card_info, address, email):
    inventory = Inventory()
    payment = Payment()
    shipping = Shipping()
    notification = Notification()
    
    if not inventory.check_stock(product_id):
        raise Exception("Out of stock")
    
    if not payment.validate_card(card_info):
        raise Exception("Invalid card")
    
    inventory.reserve(product_id, quantity)
    shipping_cost = shipping.calculate_cost(address, 1.5)
    txn_id = payment.charge(1000 + shipping_cost, card_info)
    ship_id = shipping.schedule(address)
    notification.send_confirmation(email, txn_id)
    # ...
```

```python
# ✅ Facade パターン
class OrderFacade:
    def __init__(self):
        self.inventory = Inventory()
        self.payment = Payment()
        self.shipping = Shipping()
        self.notification = Notification()
    
    def place_order(self, order: dict) -> dict:
        """注文処理を簡単なインターフェースで提供"""
        product_id = order["product_id"]
        quantity = order["quantity"]
        card_info = order["card"]
        address = order["address"]
        email = order["email"]
        price = order["price"]
        
        # 在庫確認
        if not self.inventory.check_stock(product_id):
            return {"success": False, "error": "Out of stock"}
        
        # カード検証
        if not self.payment.validate_card(card_info):
            return {"success": False, "error": "Invalid card"}
        
        # 在庫確保
        self.inventory.reserve(product_id, quantity)
        
        # 配送料計算
        shipping_cost = self.shipping.calculate_cost(address, 1.5)
        
        # 決済
        total = price * quantity + shipping_cost
        txn_id = self.payment.charge(total, card_info)
        
        # 配送予約
        ship_id = self.shipping.schedule(address)
        
        # 通知
        self.notification.send_confirmation(email, txn_id)
        
        return {
            "success": True,
            "order_id": txn_id,
            "shipping_id": ship_id,
            "total": total
        }

# 使用側はシンプル！
facade = OrderFacade()
result = facade.place_order({
    "product_id": "PROD001",
    "quantity": 2,
    "price": 1000,
    "card": {"number": "4111..."},
    "address": "東京都渋谷区",
    "email": "user@example.com"
})
print(result)
```

## 構造パターンまとめ

| パターン | 用途 | 使用場面 |
|---------|------|---------|
| Adapter | インターフェース変換 | 既存ライブラリの統合 |
| Decorator | 機能の動的追加 | ログ、キャッシュ、認証 |
| Facade | 複雑さの隠蔽 | サブシステムの簡略化 |
| Proxy | アクセス制御 | 遅延初期化、キャッシュ |
| Composite | 階層構造の統一操作 | ファイルシステム、UI |

## 理解度確認

### 問題

外部の天気APIと社内の天気APIがあり、それぞれ異なるインターフェースを持っている。これらを統一して使いたい場合、最も適切なパターンはどれか。

**A.** Singleton

**B.** Decorator

**C.** Adapter

**D.** Builder

---

### 解答・解説

**正解: C**

Adapter パターンは、異なるインターフェースを統一するのに最適です。

```python
class WeatherService(ABC):
    @abstractmethod
    def get_temperature(self, city: str) -> float:
        pass

class ExternalAPIAdapter(WeatherService):
    def __init__(self, external_api):
        self.api = external_api
    
    def get_temperature(self, city: str) -> float:
        data = self.api.fetch_weather_data(city)  # 外部API形式
        return data["temp_celsius"]

class InternalAPIAdapter(WeatherService):
    def __init__(self, internal_api):
        self.api = internal_api
    
    def get_temperature(self, city: str) -> float:
        result = self.api.query(city)  # 社内API形式
        return result.temperature
```

---

## 次のステップ

構造パターンを学びました。次は振る舞いパターンを学びましょう。

**次の単元**: [Phase 3-1: 振る舞いパターン](../phase3/01_振る舞いパターン.md)
