# Phase 3-2: よく使うパターン実践 ～ Repository, DTO, DI ～

## 学習目標

この単元を終えると、以下ができるようになります：

- Repository パターンでデータアクセスを抽象化できる
- DTO でレイヤー間のデータ転送を設計できる
- DI（依存性注入）でテスト可能なコードを書ける

## ハンズオン

### 演習1: Repository パターン

**データアクセスをビジネスロジックから分離**

```python
# ❌ 悪い例：ビジネスロジックにSQLが混在
class UserService:
    def __init__(self, db):
        self.db = db
    
    def get_active_users(self):
        # ビジネスロジック層にSQLがある
        return self.db.query("SELECT * FROM users WHERE status = 'active'")
    
    def create_user(self, name, email):
        # SQLインジェクションのリスクも
        self.db.execute(f"INSERT INTO users (name, email) VALUES ('{name}', '{email}')")
```

```python
# ✅ Repository パターン
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import List, Optional

# エンティティ
@dataclass
class User:
    id: Optional[int]
    name: str
    email: str
    status: str = "active"

# Repository インターフェース
class UserRepository(ABC):
    @abstractmethod
    def find_by_id(self, user_id: int) -> Optional[User]:
        pass
    
    @abstractmethod
    def find_by_email(self, email: str) -> Optional[User]:
        pass
    
    @abstractmethod
    def find_active(self) -> List[User]:
        pass
    
    @abstractmethod
    def save(self, user: User) -> User:
        pass
    
    @abstractmethod
    def delete(self, user_id: int) -> bool:
        pass

# 具体的な実装（MySQL）
class MySQLUserRepository(UserRepository):
    def __init__(self, connection):
        self.conn = connection
    
    def find_by_id(self, user_id: int) -> Optional[User]:
        cursor = self.conn.cursor()
        cursor.execute("SELECT id, name, email, status FROM users WHERE id = %s", (user_id,))
        row = cursor.fetchone()
        if row:
            return User(id=row[0], name=row[1], email=row[2], status=row[3])
        return None
    
    def find_by_email(self, email: str) -> Optional[User]:
        # 実装...
        pass
    
    def find_active(self) -> List[User]:
        cursor = self.conn.cursor()
        cursor.execute("SELECT id, name, email, status FROM users WHERE status = 'active'")
        return [User(id=row[0], name=row[1], email=row[2], status=row[3]) 
                for row in cursor.fetchall()]
    
    def save(self, user: User) -> User:
        cursor = self.conn.cursor()
        if user.id is None:
            cursor.execute(
                "INSERT INTO users (name, email, status) VALUES (%s, %s, %s)",
                (user.name, user.email, user.status)
            )
            user.id = cursor.lastrowid
        else:
            cursor.execute(
                "UPDATE users SET name = %s, email = %s, status = %s WHERE id = %s",
                (user.name, user.email, user.status, user.id)
            )
        self.conn.commit()
        return user
    
    def delete(self, user_id: int) -> bool:
        cursor = self.conn.cursor()
        cursor.execute("DELETE FROM users WHERE id = %s", (user_id,))
        self.conn.commit()
        return cursor.rowcount > 0

# テスト用のインメモリ実装
class InMemoryUserRepository(UserRepository):
    def __init__(self):
        self._users: dict[int, User] = {}
        self._next_id = 1
    
    def find_by_id(self, user_id: int) -> Optional[User]:
        return self._users.get(user_id)
    
    def find_by_email(self, email: str) -> Optional[User]:
        for user in self._users.values():
            if user.email == email:
                return user
        return None
    
    def find_active(self) -> List[User]:
        return [u for u in self._users.values() if u.status == "active"]
    
    def save(self, user: User) -> User:
        if user.id is None:
            user.id = self._next_id
            self._next_id += 1
        self._users[user.id] = user
        return user
    
    def delete(self, user_id: int) -> bool:
        if user_id in self._users:
            del self._users[user_id]
            return True
        return False

# Service層（Repositoryに依存）
class UserService:
    def __init__(self, user_repository: UserRepository):
        self.user_repository = user_repository
    
    def get_active_users(self) -> List[User]:
        return self.user_repository.find_active()
    
    def register_user(self, name: str, email: str) -> User:
        existing = self.user_repository.find_by_email(email)
        if existing:
            raise ValueError("Email already exists")
        
        user = User(id=None, name=name, email=email)
        return self.user_repository.save(user)
```

### 演習2: DTO（Data Transfer Object）

**レイヤー間のデータ転送を明確化**

```python
from dataclasses import dataclass, asdict
from typing import Optional
from datetime import datetime

# Entity（内部用、DBと対応）
@dataclass
class UserEntity:
    id: int
    name: str
    email: str
    password_hash: str
    created_at: datetime
    updated_at: datetime
    is_deleted: bool = False

# Request DTO（外部からの入力）
@dataclass
class CreateUserRequest:
    name: str
    email: str
    password: str
    
    def validate(self):
        if not self.name or len(self.name) < 2:
            raise ValueError("Name must be at least 2 characters")
        if not self.email or "@" not in self.email:
            raise ValueError("Invalid email format")
        if not self.password or len(self.password) < 8:
            raise ValueError("Password must be at least 8 characters")

@dataclass
class UpdateUserRequest:
    name: Optional[str] = None
    email: Optional[str] = None

# Response DTO（外部への出力）
@dataclass
class UserResponse:
    id: int
    name: str
    email: str
    created_at: str
    
    @classmethod
    def from_entity(cls, entity: UserEntity) -> 'UserResponse':
        return cls(
            id=entity.id,
            name=entity.name,
            email=entity.email,
            created_at=entity.created_at.isoformat()
        )
    
    def to_dict(self) -> dict:
        return asdict(self)

# Controller / API Handler
class UserController:
    def __init__(self, user_service):
        self.user_service = user_service
    
    def create_user(self, request_data: dict) -> dict:
        # Request DTO でバリデーション
        request = CreateUserRequest(**request_data)
        request.validate()
        
        # Service 呼び出し
        user_entity = self.user_service.create_user(
            name=request.name,
            email=request.email,
            password=request.password
        )
        
        # Response DTO で出力
        response = UserResponse.from_entity(user_entity)
        return response.to_dict()
```

### 演習3: DI（依存性注入）

**依存関係を外部から注入**

```python
# ❌ 悪い例：密結合
class OrderService:
    def __init__(self):
        self.db = MySQLDatabase()  # 具体的な実装に依存
        self.mailer = SMTPMailer()  # テスト困難
        self.logger = FileLogger()
    
    def create_order(self, order_data):
        # ...
        pass
```

```python
# ✅ DI（Constructor Injection）
from abc import ABC, abstractmethod

# インターフェース定義
class Database(ABC):
    @abstractmethod
    def query(self, sql: str): pass
    @abstractmethod
    def execute(self, sql: str, params: tuple): pass

class Mailer(ABC):
    @abstractmethod
    def send(self, to: str, subject: str, body: str): pass

class Logger(ABC):
    @abstractmethod
    def info(self, message: str): pass
    @abstractmethod
    def error(self, message: str): pass

# 具体的な実装
class MySQLDatabase(Database):
    def query(self, sql: str):
        print(f"MySQL Query: {sql}")
        return []
    
    def execute(self, sql: str, params: tuple):
        print(f"MySQL Execute: {sql} with {params}")

class SMTPMailer(Mailer):
    def send(self, to: str, subject: str, body: str):
        print(f"SMTP: Sending to {to}")

class ConsoleLogger(Logger):
    def info(self, message: str):
        print(f"[INFO] {message}")
    
    def error(self, message: str):
        print(f"[ERROR] {message}")

# Service（依存を注入）
class OrderService:
    def __init__(self, db: Database, mailer: Mailer, logger: Logger):
        self.db = db
        self.mailer = mailer
        self.logger = logger
    
    def create_order(self, order_data: dict) -> dict:
        self.logger.info(f"Creating order: {order_data}")
        
        # DB保存
        self.db.execute(
            "INSERT INTO orders (user_id, total) VALUES (%s, %s)",
            (order_data["user_id"], order_data["total"])
        )
        
        # メール送信
        self.mailer.send(
            to=order_data["email"],
            subject="Order Confirmation",
            body=f"Your order total: {order_data['total']}"
        )
        
        return {"order_id": 1, "status": "created"}
```

```python
# テスト用のモック
class MockDatabase(Database):
    def __init__(self):
        self.queries = []
        self.executions = []
    
    def query(self, sql: str):
        self.queries.append(sql)
        return []
    
    def execute(self, sql: str, params: tuple):
        self.executions.append((sql, params))

class MockMailer(Mailer):
    def __init__(self):
        self.sent = []
    
    def send(self, to: str, subject: str, body: str):
        self.sent.append({"to": to, "subject": subject, "body": body})

class MockLogger(Logger):
    def __init__(self):
        self.logs = []
    
    def info(self, message: str):
        self.logs.append(("INFO", message))
    
    def error(self, message: str):
        self.logs.append(("ERROR", message))

# テスト
def test_create_order():
    mock_db = MockDatabase()
    mock_mailer = MockMailer()
    mock_logger = MockLogger()
    
    service = OrderService(mock_db, mock_mailer, mock_logger)
    
    result = service.create_order({
        "user_id": 1,
        "total": 1000,
        "email": "test@example.com"
    })
    
    assert result["status"] == "created"
    assert len(mock_db.executions) == 1
    assert len(mock_mailer.sent) == 1
    assert mock_mailer.sent[0]["to"] == "test@example.com"

test_create_order()
print("Test passed!")
```

```python
# DI コンテナ（シンプルな実装）
class Container:
    def __init__(self):
        self._services = {}
        self._factories = {}
    
    def register(self, interface, implementation):
        """具体的な実装を登録"""
        self._services[interface] = implementation
    
    def register_factory(self, interface, factory):
        """ファクトリ関数を登録"""
        self._factories[interface] = factory
    
    def resolve(self, interface):
        """インターフェースから実装を取得"""
        if interface in self._services:
            return self._services[interface]
        if interface in self._factories:
            return self._factories[interface](self)
        raise ValueError(f"No registration for {interface}")

# 使用例
container = Container()
container.register(Database, MySQLDatabase())
container.register(Mailer, SMTPMailer())
container.register(Logger, ConsoleLogger())
container.register_factory(
    OrderService,
    lambda c: OrderService(
        c.resolve(Database),
        c.resolve(Mailer),
        c.resolve(Logger)
    )
)

order_service = container.resolve(OrderService)
```

## パターン比較表

| パターン | 目的 | メリット |
|---------|------|---------|
| Repository | データアクセス抽象化 | DB変更に強い、テスト容易 |
| DTO | レイヤー間データ転送 | 明確なAPI契約、バリデーション |
| DI | 依存関係の外部化 | 疎結合、テスト容易 |

## 理解度確認

### 問題

以下のコードをテストしやすくするために最も適切な改善はどれか。

```python
class ReportService:
    def generate_report(self, data):
        db = MySQLDatabase()
        results = db.query("SELECT * FROM sales")
        # レポート生成処理
```

**A.** MySQLDatabase をグローバル変数にする

**B.** Database インターフェースを作り、コンストラクタで注入する

**C.** generate_report メソッド内でモックを作成する

**D.** MySQLDatabase に is_test フラグを追加する

---

### 解答・解説

**正解: B**

DI（依存性注入）により：
- Database インターフェースに依存
- テスト時はモックを注入可能
- 本番では MySQLDatabase を注入

```python
class ReportService:
    def __init__(self, db: Database):  # インターフェースに依存
        self.db = db
    
    def generate_report(self, data):
        results = self.db.query("SELECT * FROM sales")
```

---

## 次のステップ

よく使うパターンを学びました。次はアーキテクチャパターンを学びましょう。

**次の単元**: [Phase 4-1: レイヤードアーキテクチャ](../phase4/01_レイヤードアーキテクチャ.md)
