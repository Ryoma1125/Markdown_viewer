# Phase 5-2: プロセスを操る ～ kill, バックグラウンド実行 ～

## 学習目標

この単元を終えると、以下ができるようになります：

- `kill` コマンドでプロセスにシグナルを送れる
- フォアグラウンド・バックグラウンド実行を使い分けられる
- `nohup` でログアウト後もプロセスを継続できる
- ジョブ制御（`jobs`, `fg`, `bg`）ができる

## 概念解説

### シグナルとは？

プロセスに送る「通知」や「命令」のこと。

```mermaid
graph LR
    User[ユーザー/システム] -->|シグナル送信| Process[プロセス]
    Process -->|対応アクション| Result[終了/一時停止/無視/etc]

    style Process fill:#90EE90
```

**Windowsで例えると：**
- Ctrl+Alt+Delete → タスクマネージャーで「タスクの終了」
- シグナル = もっと細かい指示ができる版

### 主要なシグナル

| 番号 | 名前 | 説明 | 用途 |
|-----|------|------|------|
| 1 | HUP | ハングアップ | 設定再読み込み |
| 2 | INT | 割り込み | Ctrl+C |
| 9 | KILL | 強制終了 | **無視できない** |
| 15 | TERM | 終了要求 | デフォルト（お行儀よく） |
| 18 | CONT | 再開 | 停止したプロセスを再開 |
| 19 | STOP | 停止 | **無視できない** |
| 20 | TSTP | 端末停止 | Ctrl+Z |

### フォアグラウンド vs バックグラウンド

```mermaid
graph TD
    subgraph "フォアグラウンド"
        FG[プロセス] --> Terminal[端末を占有]
        Terminal --> Wait[完了まで待機]
    end

    subgraph "バックグラウンド"
        BG[プロセス &] --> NoBlock[端末を占有しない]
        NoBlock --> Continue[他の作業ができる]
    end

    style FG fill:#FFB6C1
    style BG fill:#90EE90
```

## 基本コマンド

### kill

```bash
kill PID                # SIGTERM(15) を送信（デフォルト）
kill -9 PID             # SIGKILL を送信（強制終了）
kill -15 PID            # SIGTERM を明示的に
kill -HUP PID           # SIGHUP を送信
kill -l                 # シグナル一覧を表示

# 複数プロセスを終了
kill PID1 PID2 PID3
```

### killall / pkill

```bash
killall プロセス名       # 名前で kill
pkill パターン           # パターンマッチで kill
pkill -u username       # 特定ユーザーのプロセスを kill
```

### ジョブ制御

```bash
command &               # バックグラウンドで実行
jobs                    # ジョブ一覧
fg                      # 直近のジョブをフォアグラウンドに
fg %1                   # ジョブ番号1をフォアグラウンドに
bg                      # 停止中のジョブをバックグラウンドで再開
bg %1                   # ジョブ番号1をバックグラウンドで再開
```

### nohup

```bash
nohup command &         # ログアウト後も継続
nohup command > output.log 2>&1 &  # 出力もリダイレクト
```

### disown

```bash
disown                  # 全ジョブをシェルから切り離す
disown %1               # ジョブ1を切り離す
disown -h %1            # HUPシグナルを受けないようにする
```

## ハンズオン

### 演習1: シグナルの基本

```bash
# 1. シグナル一覧を確認
kill -l

# 2. バックグラウンドプロセスを作成
sleep 100 &
echo "PID: $!"

# 3. プロセスを確認
ps aux | grep sleep

# 4. SIGTERM で終了要求
kill $(pgrep -f "sleep 100")

# 5. 確認
ps aux | grep sleep
```

### 演習2: Ctrl+C と Ctrl+Z

```bash
# 1. フォアグラウンドで sleep を実行
sleep 60

# Ctrl+C を押す → プロセス終了（SIGINT）

# 2. もう一度実行
sleep 60

# Ctrl+Z を押す → プロセス一時停止（SIGTSTP）
# [1]+  Stopped                 sleep 60

# 3. ジョブ一覧を確認
jobs
# [1]+  Stopped                 sleep 60

# 4. バックグラウンドで再開
bg
jobs
# [1]+  Running                 sleep 60 &

# 5. フォアグラウンドに戻す
fg
# Ctrl+C で終了
```

### 演習3: バックグラウンド実行

```bash
# 1. & でバックグラウンド実行
sleep 30 &
# [1] 12345 ← ジョブ番号と PID

# 2. 複数のバックグラウンドジョブ
sleep 40 &
sleep 50 &

# 3. ジョブ一覧
jobs
# [1]   Running                 sleep 30 &
# [2]-  Running                 sleep 40 &
# [3]+  Running                 sleep 50 &

# 4. 特定のジョブをフォアグラウンドに
fg %2

# Ctrl+C で終了

# 5. 残りを確認
jobs
```

### 演習4: kill の使い分け

```bash
# テスト用のプロセスを作成
sleep 1000 &
PID=$!
echo "PID: $PID"

# 1. まず SIGTERM（お行儀よく）
kill $PID
ps -p $PID  # 終了確認

# 2. 強制終了が必要な場合（再度作成）
sleep 1000 &
PID=$!

# SIGKILL（無視できない、強制終了）
kill -9 $PID
ps -p $PID  # 終了確認
```

### 演習5: killall と pkill

```bash
# 複数の sleep プロセスを作成
sleep 200 &
sleep 201 &
sleep 202 &

# 1. killall で一括終了
killall sleep
jobs

# 再度作成
sleep 200 &
sleep 201 &
sleep 202 &

# 2. pkill でパターンマッチ
pkill -f "sleep 20"
jobs
```

### 演習6: nohup でログアウト後も継続

```bash
# 1. nohup でバックグラウンド実行
nohup sleep 300 &

# 2. 確認
jobs
cat nohup.out  # デフォルトの出力先

# 3. 出力先を指定
nohup sh -c 'echo "start"; sleep 10; echo "done"' > mylog.txt 2>&1 &

# 4. しばらく待ってから確認
cat mylog.txt

# 5. プロセスを終了
pkill -f "sleep 300"
```

### 演習7: 実践シナリオ - 暴走プロセスの対処

```bash
# 暴走プロセスのシミュレーション（CPU を消費するループ）
cat << 'EOF' > ~/練習場/cpu_hog.sh
#!/bin/bash
while true; do
    echo "working..." > /dev/null
done
EOF
chmod +x ~/練習場/cpu_hog.sh

# 1. バックグラウンドで実行
~/練習場/cpu_hog.sh &

# 2. top で確認（CPUを消費している）
top -bn1 | head -15

# 3. プロセスを特定
ps aux | grep cpu_hog

# 4. まず TERM で試す
pkill -f cpu_hog.sh

# もし終了しなければ
# pkill -9 -f cpu_hog.sh

# 5. 確認
ps aux | grep cpu_hog

# クリーンアップ
rm ~/練習場/cpu_hog.sh
```

### 演習8: HUP シグナルの活用

```bash
# HUP は設定再読み込みによく使われる
# 例: sshd の設定を再読み込み（要root）

# シミュレーション用スクリプト
cat << 'EOF' > ~/練習場/daemon_sim.sh
#!/bin/bash
trap 'echo "Received HUP - reloading config"' HUP
trap 'echo "Received TERM - exiting"; exit 0' TERM

echo "Daemon started (PID: $$)"
while true; do
    sleep 1
done
EOF
chmod +x ~/練習場/daemon_sim.sh

# バックグラウンドで実行
~/練習場/daemon_sim.sh &
PID=$!

# HUP を送信
kill -HUP $PID
# "Received HUP - reloading config" と表示される

# TERM で終了
kill $PID

# クリーンアップ
rm ~/練習場/daemon_sim.sh
```

## 試験のツボ

### シグナル番号は覚える！

| シグナル | 番号 | キー | 用途 |
|---------|------|------|------|
| SIGHUP | 1 | - | 設定再読み込み |
| SIGINT | 2 | Ctrl+C | 割り込み終了 |
| SIGKILL | 9 | - | 強制終了（**無視不可**） |
| SIGTERM | 15 | - | 通常終了（デフォルト） |
| SIGTSTP | 20 | Ctrl+Z | 一時停止 |

### kill -9 vs kill -15

```bash
kill PID      # = kill -15 PID（お願いベース）
kill -9 PID   # 強制終了（最後の手段）
```

**実務では:**
1. まず `kill PID`（SIGTERM）を試す
2. 終了しなければ `kill -9 PID`（SIGKILL）

### ジョブ番号の指定

```bash
jobs
# [1]-  Running   sleep 100 &
# [2]+  Running   sleep 200 &

fg %1         # ジョブ1をフォアグラウンドに
kill %2       # ジョブ2を kill
```

### nohup と & の違い

| コマンド | ターミナル閉じたら | 出力 |
|---------|-------------------|------|
| `cmd &` | 終了する | 端末に表示 |
| `nohup cmd &` | 継続する | nohup.out に保存 |

## 理解度確認

### 問題

シグナル番号 9（SIGKILL）の特徴として正しいものはどれか。

**A.** プロセスはこのシグナルをトラップ（捕捉）して無視できる

**B.** `kill` コマンドのデフォルトシグナルである

**C.** プロセスに設定ファイルの再読み込みを指示する

**D.** プロセスを強制終了させ、トラップできない

---

### 解答・解説

**正解: D**

- **A.** 誤り。SIGKILL はトラップ（捕捉）できません。これが SIGTERM との重要な違いです。
- **B.** 誤り。デフォルトは SIGTERM（15）です。
- **C.** 誤り。設定再読み込みは SIGHUP（1）です。
- **D.** 正解。SIGKILL は強制終了シグナルで、プロセスは絶対に捕捉・無視できません。

**使い分け:**
- 通常は SIGTERM（15）で終了を要求
- 応答しない場合のみ SIGKILL（9）を使用

---

## Phase 5 まとめ

Phase 5 では以下をマスターしました：

1. **プロセス監視**: `ps`, `top` でプロセスを確認
2. **シグナル**: `kill` でプロセスに指示を送る
3. **ジョブ制御**: フォアグラウンド/バックグラウンドの切り替え
4. **永続化**: `nohup` でログアウト後も継続

これらのスキルは、サーバー運用やトラブルシューティングで必須です。

---

## 次のステップ

プロセス管理をマスターしたら、次はシェルスクリプトの力を学びましょう！

**次の単元**: [Phase 6-1: シェル変数入門 ～ 変数で効率化 ～](../phase6/01_シェル変数.md)
