# Phase 2-2: バリデーションとエラー処理

## 学習目標

この単元を終えると、以下ができるようになります：

- Pydantic で高度なバリデーションができる
- カスタム例外を定義できる
- 一貫したエラーレスポンスを返せる

## Pydantic バリデーション

### 基本的なバリデーション

```python
from pydantic import BaseModel, Field, EmailStr, field_validator
from typing import Optional
from datetime import date

class UserCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    email: EmailStr
    age: int = Field(..., ge=0, le=150)
    password: str = Field(..., min_length=8)
    birth_date: Optional[date] = None
    website: Optional[str] = Field(None, pattern=r'^https?://')
    
    @field_validator('name')
    @classmethod
    def name_must_not_contain_numbers(cls, v: str) -> str:
        if any(char.isdigit() for char in v):
            raise ValueError('Name must not contain numbers')
        return v.strip()
    
    @field_validator('password')
    @classmethod
    def password_strength(cls, v: str) -> str:
        if not any(char.isupper() for char in v):
            raise ValueError('Password must contain uppercase letter')
        if not any(char.islower() for char in v):
            raise ValueError('Password must contain lowercase letter')
        if not any(char.isdigit() for char in v):
            raise ValueError('Password must contain digit')
        return v
```

### モデル全体のバリデーション

```python
from pydantic import BaseModel, model_validator

class DateRange(BaseModel):
    start_date: date
    end_date: date
    
    @model_validator(mode='after')
    def check_dates(self):
        if self.end_date < self.start_date:
            raise ValueError('end_date must be after start_date')
        return self
```

### ネストしたモデル

```python
class Address(BaseModel):
    street: str
    city: str
    country: str
    postal_code: str

class Company(BaseModel):
    name: str
    address: Address

class UserWithCompany(BaseModel):
    name: str
    email: EmailStr
    company: Optional[Company] = None
```

## エラーハンドリング

### HTTPException

```python
from fastapi import FastAPI, HTTPException, status

app = FastAPI()

@app.get("/users/{user_id}")
def get_user(user_id: int):
    user = users_db.get(user_id)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found",
            headers={"X-Error-Code": "USER_NOT_FOUND"}
        )
    return user
```

### カスタム例外

```python
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse

# カスタム例外クラス
class AppException(Exception):
    def __init__(self, code: str, message: str, status_code: int = 400):
        self.code = code
        self.message = message
        self.status_code = status_code

class NotFoundError(AppException):
    def __init__(self, resource: str, resource_id: int):
        super().__init__(
            code="NOT_FOUND",
            message=f"{resource} with id {resource_id} not found",
            status_code=404
        )

class ValidationError(AppException):
    def __init__(self, message: str, details: list = None):
        super().__init__(
            code="VALIDATION_ERROR",
            message=message,
            status_code=422
        )
        self.details = details or []

class UnauthorizedError(AppException):
    def __init__(self):
        super().__init__(
            code="UNAUTHORIZED",
            message="Authentication required",
            status_code=401
        )

# 例外ハンドラー
app = FastAPI()

@app.exception_handler(AppException)
async def app_exception_handler(request: Request, exc: AppException):
    content = {
        "error": {
            "code": exc.code,
            "message": exc.message,
        }
    }
    if hasattr(exc, 'details') and exc.details:
        content["error"]["details"] = exc.details
    
    return JSONResponse(
        status_code=exc.status_code,
        content=content
    )

# 使用例
@app.get("/users/{user_id}")
def get_user(user_id: int):
    user = users_db.get(user_id)
    if not user:
        raise NotFoundError("User", user_id)
    return user
```

### バリデーションエラーのカスタマイズ

```python
from fastapi import FastAPI, Request
from fastapi.exceptions import RequestValidationError
from fastapi.responses import JSONResponse

app = FastAPI()

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    errors = []
    for error in exc.errors():
        errors.append({
            "field": ".".join(str(loc) for loc in error["loc"][1:]),  # body. を除去
            "message": error["msg"],
            "type": error["type"]
        })
    
    return JSONResponse(
        status_code=422,
        content={
            "error": {
                "code": "VALIDATION_ERROR",
                "message": "Request validation failed",
                "details": errors
            }
        }
    )
```

### グローバル例外ハンドラー

```python
import traceback
import uuid
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
import logging

logger = logging.getLogger(__name__)

app = FastAPI()

@app.exception_handler(Exception)
async def global_exception_handler(request: Request, exc: Exception):
    # リクエストIDを生成
    request_id = str(uuid.uuid4())
    
    # ログに記録
    logger.error(
        f"Unhandled exception: {exc}",
        extra={
            "request_id": request_id,
            "path": request.url.path,
            "method": request.method,
            "traceback": traceback.format_exc()
        }
    )
    
    return JSONResponse(
        status_code=500,
        content={
            "error": {
                "code": "INTERNAL_ERROR",
                "message": "An unexpected error occurred",
                "request_id": request_id
            }
        }
    )
```

## ミドルウェア

### リクエストID追加

```python
from fastapi import FastAPI, Request
import uuid

app = FastAPI()

@app.middleware("http")
async def add_request_id(request: Request, call_next):
    request_id = str(uuid.uuid4())
    request.state.request_id = request_id
    
    response = await call_next(request)
    response.headers["X-Request-ID"] = request_id
    
    return response
```

### ロギング

```python
import time
import logging

logger = logging.getLogger(__name__)

@app.middleware("http")
async def log_requests(request: Request, call_next):
    start_time = time.time()
    
    response = await call_next(request)
    
    duration = time.time() - start_time
    logger.info(
        f"{request.method} {request.url.path} "
        f"- {response.status_code} - {duration:.3f}s"
    )
    
    return response
```

## 完全な例

```python
from fastapi import FastAPI, Request, Depends, HTTPException
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from pydantic import BaseModel, EmailStr, Field, field_validator
import logging

# ロガー設定
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# 例外クラス
class AppException(Exception):
    def __init__(self, code: str, message: str, status_code: int = 400):
        self.code = code
        self.message = message
        self.status_code = status_code

# アプリケーション
app = FastAPI(title="My API")

# 例外ハンドラー
@app.exception_handler(AppException)
async def app_exception_handler(request: Request, exc: AppException):
    return JSONResponse(
        status_code=exc.status_code,
        content={"error": {"code": exc.code, "message": exc.message}}
    )

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    return JSONResponse(
        status_code=422,
        content={
            "error": {
                "code": "VALIDATION_ERROR",
                "message": "Validation failed",
                "details": [
                    {"field": ".".join(str(l) for l in e["loc"][1:]), "message": e["msg"]}
                    for e in exc.errors()
                ]
            }
        }
    )

# モデル
class UserCreate(BaseModel):
    name: str = Field(..., min_length=1, max_length=100)
    email: EmailStr

# エンドポイント
@app.post("/users", status_code=201)
def create_user(user: UserCreate):
    return {"id": 1, "name": user.name, "email": user.email}
```

## 理解度確認

### 問題

FastAPI でカスタム例外をレスポンスに変換するために使用するデコレータはどれか。

**A.** `@app.error_handler`

**B.** `@app.exception_handler`

**C.** `@app.on_exception`

**D.** `@app.catch`

---

### 解答・解説

**正解: B**

```python
@app.exception_handler(MyException)
async def my_exception_handler(request: Request, exc: MyException):
    return JSONResponse(
        status_code=400,
        content={"error": exc.message}
    )
```

---

## 次のステップ

バリデーションを学びました。次は認証と認可を学びましょう。

**次の単元**: [Phase 3-1: 認証と認可](../phase3/01_認証と認可.md)
